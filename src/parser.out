Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    CONTINUE
    EXPORT
    FALSE
    IMPORT
    LATE
    LBRACKET
    NOT
    NULL_TYPE
    RBRACKET
    RETURN
    STATIC
    TRUE

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statements statement
Rule 3     statements -> statement
Rule 4     statement -> expression SEMICOLON
Rule 5     statement -> declaration
Rule 6     statement -> assignation
Rule 7     statement -> function
Rule 8     statement -> if
Rule 9     statement -> while
Rule 10    statement -> for
Rule 11    statement -> print
Rule 12    statement -> input
Rule 13    statement -> class_def
Rule 14    statement -> enum
Rule 15    statement -> try
Rule 16    statement -> switch
Rule 17    statement -> empty
Rule 18    declaration -> varType ID SEMICOLON
Rule 19    assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON
Rule 20    assignation -> ID ASSIGN_OPERATOR variable SEMICOLON
Rule 21    varType -> INT_TYPE
Rule 22    varType -> STRING_TYPE
Rule 23    varType -> NUM_TYPE
Rule 24    varType -> DOUBLE_TYPE
Rule 25    varType -> BOOL_TYPE
Rule 26    varType -> LIST_TYPE
Rule 27    varType -> MAP_TYPE
Rule 28    varType -> SET_TYPE
Rule 29    varType -> VAR
Rule 30    varType -> CONST
Rule 31    varType -> FINAL
Rule 32    varType -> VOID
Rule 33    variable -> INT
Rule 34    variable -> DOUBLE
Rule 35    variable -> STRING
Rule 36    variable -> BOOL
Rule 37    variable -> NULL
Rule 38    variable -> ID
Rule 39    variable -> expression
Rule 40    expression -> expression PLUS term
Rule 41    expression -> expression MINUS term
Rule 42    expression -> term
Rule 43    term -> term TIMES factor
Rule 44    term -> term DIVIDE factor
Rule 45    term -> term MODULE factor
Rule 46    term -> factor
Rule 47    factor -> INT
Rule 48    factor -> DOUBLE
Rule 49    booleanExpression -> variable EQUALS variable
Rule 50    booleanExpression -> variable NOT_EQUALS variable
Rule 51    booleanExpression -> variable GREATER_THAN variable
Rule 52    booleanExpression -> variable LESS_THAN variable
Rule 53    booleanExpression -> variable GREATER_THAN_OR_EQUALS variable
Rule 54    booleanExpression -> variable LESS_THAN_OR_EQUALS variable
Rule 55    booleanExpression -> booleanExpression AND booleanExpression
Rule 56    booleanExpression -> booleanExpression OR booleanExpression
Rule 57    if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
Rule 58    if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
Rule 59    while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
Rule 60    for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
Rule 61    for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
Rule 62    increment -> ID INCREMENT
Rule 63    decrement -> ID DECREMENT
Rule 64    function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
Rule 65    function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
Rule 66    typedef -> TYPEDEF ID ASSIGN_OPERATOR varType function LPARENTHESIS parameters RPARENTHESIS SEMICOLON
Rule 67    enum -> ENUM ID LBRACE enum_values RBRACE
Rule 68    enum_values -> enum_values COMMA ID
Rule 69    enum_values -> ID
Rule 70    try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
Rule 71    switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
Rule 72    cases -> cases case
Rule 73    cases -> case
Rule 74    case -> CASE variable COLON statements BREAK SEMICOLON
Rule 75    default_case -> DEFAULT COLON statements
Rule 76    parameters -> parameters COMMA parameter
Rule 77    parameters -> parameter
Rule 78    parameters -> empty
Rule 79    parameter -> varType ID
Rule 80    print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
Rule 81    input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
Rule 82    class_def -> CLASS ID LBRACE class_members RBRACE
Rule 83    class_members -> class_members class_member
Rule 84    class_members -> class_member
Rule 85    class_member -> varType ID SEMICOLON
Rule 86    class_member -> function
Rule 87    empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 55
ARROW                : 65
ASSIGN_OPERATOR      : 19 20 66 81
BOOL                 : 36
BOOL_TYPE            : 25
BREAK                : 74
CASE                 : 74
CLASS                : 82
COLON                : 74 75
COMMA                : 68 76
CONST                : 30
CONTINUE             : 
DECREMENT            : 63
DEFAULT              : 75
DIVIDE               : 44
DOT                  : 81
DOUBLE               : 34 48
DOUBLE_TYPE          : 24
ELSE                 : 58
ENUM                 : 67
EQUALS               : 49
EXPORT               : 
FALSE                : 
FINAL                : 31
FINALLY              : 70
FOR                  : 60 61
GREATER_THAN         : 51
GREATER_THAN_OR_EQUALS : 53
ID                   : 18 19 20 38 62 63 64 65 66 67 68 69 79 81 82 85
IF                   : 57 58
IMPORT               : 
INCREMENT            : 62
INT                  : 33 47
INT_TYPE             : 21
LATE                 : 
LBRACE               : 57 58 58 59 60 61 64 67 70 70 71 82
LBRACKET             : 
LESS_THAN            : 52
LESS_THAN_OR_EQUALS  : 54
LIST_TYPE            : 26
LPARENTHESIS         : 57 58 59 60 61 64 65 66 71 80 81
MAP_TYPE             : 27
MINUS                : 41
MODULE               : 45
NOT                  : 
NOT_EQUALS           : 50
NULL                 : 37
NULL_TYPE            : 
NUM_TYPE             : 23
OR                   : 56
PLUS                 : 40
PRINT                : 80
RBRACE               : 57 58 58 59 60 61 64 67 70 70 71 82
RBRACKET             : 
READ                 : 81
RETURN               : 
RPARENTHESIS         : 57 58 59 60 61 64 65 66 71 80 81
SEMICOLON            : 4 18 19 20 60 61 65 66 74 80 81 85
SET_TYPE             : 28
STATIC               : 
STDIN                : 81
STRING               : 35
STRING_TYPE          : 22
SWITCH               : 71
TIMES                : 43
TRUE                 : 
TRY                  : 70
TYPEDEF              : 66
VAR                  : 29
VOID                 : 32
WHILE                : 59
error                : 

Nonterminals, with rules where they appear

assignation          : 6 60 61
booleanExpression    : 55 55 56 56 57 58 59 60 61
case                 : 72 73
cases                : 71 72
class_def            : 13
class_member         : 83 84
class_members        : 82 83
declaration          : 5
decrement            : 61
default_case         : 71
empty                : 17 78
enum                 : 14
enum_values          : 67 68
expression           : 4 39 40 41 65 80
factor               : 43 44 45 46
for                  : 10
function             : 7 66 86
if                   : 8
increment            : 60
input                : 12
parameter            : 76 77
parameters           : 64 65 66 76
print                : 11
program              : 0
statement            : 2 3
statements           : 1 2 57 58 58 59 60 61 64 70 70 74 75
switch               : 16
term                 : 40 41 42 43 44 45
try                  : 15
typedef              : 
varType              : 18 19 64 65 66 79 85
variable             : 19 20 49 49 50 50 51 51 52 52 53 53 54 54 71 74
while                : 9

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    $end            reduce using rule 87 (empty -> .)
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 1

    (0) S' -> program .



state 2

    (1) program -> statements .
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 1 (program -> statements .)
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    $end            reduce using rule 1 (program -> statements .)
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]
  ! $end            [ reduce using rule 87 (empty -> .) ]

    statement                      shift and go to state 44
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 3

    (3) statements -> statement .

    ID              reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    WHILE           reduce using rule 3 (statements -> statement .)
    FOR             reduce using rule 3 (statements -> statement .)
    PRINT           reduce using rule 3 (statements -> statement .)
    CLASS           reduce using rule 3 (statements -> statement .)
    ENUM            reduce using rule 3 (statements -> statement .)
    TRY             reduce using rule 3 (statements -> statement .)
    SWITCH          reduce using rule 3 (statements -> statement .)
    INT_TYPE        reduce using rule 3 (statements -> statement .)
    STRING_TYPE     reduce using rule 3 (statements -> statement .)
    NUM_TYPE        reduce using rule 3 (statements -> statement .)
    DOUBLE_TYPE     reduce using rule 3 (statements -> statement .)
    BOOL_TYPE       reduce using rule 3 (statements -> statement .)
    LIST_TYPE       reduce using rule 3 (statements -> statement .)
    MAP_TYPE        reduce using rule 3 (statements -> statement .)
    SET_TYPE        reduce using rule 3 (statements -> statement .)
    VAR             reduce using rule 3 (statements -> statement .)
    CONST           reduce using rule 3 (statements -> statement .)
    FINAL           reduce using rule 3 (statements -> statement .)
    VOID            reduce using rule 3 (statements -> statement .)
    INT             reduce using rule 3 (statements -> statement .)
    DOUBLE          reduce using rule 3 (statements -> statement .)
    $end            reduce using rule 3 (statements -> statement .)
    RBRACE          reduce using rule 3 (statements -> statement .)
    BREAK           reduce using rule 3 (statements -> statement .)


state 4

    (4) statement -> expression . SEMICOLON
    (40) expression -> expression . PLUS term
    (41) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 45
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47


state 5

    (5) statement -> declaration .

    ID              reduce using rule 5 (statement -> declaration .)
    IF              reduce using rule 5 (statement -> declaration .)
    WHILE           reduce using rule 5 (statement -> declaration .)
    FOR             reduce using rule 5 (statement -> declaration .)
    PRINT           reduce using rule 5 (statement -> declaration .)
    CLASS           reduce using rule 5 (statement -> declaration .)
    ENUM            reduce using rule 5 (statement -> declaration .)
    TRY             reduce using rule 5 (statement -> declaration .)
    SWITCH          reduce using rule 5 (statement -> declaration .)
    INT_TYPE        reduce using rule 5 (statement -> declaration .)
    STRING_TYPE     reduce using rule 5 (statement -> declaration .)
    NUM_TYPE        reduce using rule 5 (statement -> declaration .)
    DOUBLE_TYPE     reduce using rule 5 (statement -> declaration .)
    BOOL_TYPE       reduce using rule 5 (statement -> declaration .)
    LIST_TYPE       reduce using rule 5 (statement -> declaration .)
    MAP_TYPE        reduce using rule 5 (statement -> declaration .)
    SET_TYPE        reduce using rule 5 (statement -> declaration .)
    VAR             reduce using rule 5 (statement -> declaration .)
    CONST           reduce using rule 5 (statement -> declaration .)
    FINAL           reduce using rule 5 (statement -> declaration .)
    VOID            reduce using rule 5 (statement -> declaration .)
    INT             reduce using rule 5 (statement -> declaration .)
    DOUBLE          reduce using rule 5 (statement -> declaration .)
    $end            reduce using rule 5 (statement -> declaration .)
    RBRACE          reduce using rule 5 (statement -> declaration .)
    BREAK           reduce using rule 5 (statement -> declaration .)


state 6

    (6) statement -> assignation .

    ID              reduce using rule 6 (statement -> assignation .)
    IF              reduce using rule 6 (statement -> assignation .)
    WHILE           reduce using rule 6 (statement -> assignation .)
    FOR             reduce using rule 6 (statement -> assignation .)
    PRINT           reduce using rule 6 (statement -> assignation .)
    CLASS           reduce using rule 6 (statement -> assignation .)
    ENUM            reduce using rule 6 (statement -> assignation .)
    TRY             reduce using rule 6 (statement -> assignation .)
    SWITCH          reduce using rule 6 (statement -> assignation .)
    INT_TYPE        reduce using rule 6 (statement -> assignation .)
    STRING_TYPE     reduce using rule 6 (statement -> assignation .)
    NUM_TYPE        reduce using rule 6 (statement -> assignation .)
    DOUBLE_TYPE     reduce using rule 6 (statement -> assignation .)
    BOOL_TYPE       reduce using rule 6 (statement -> assignation .)
    LIST_TYPE       reduce using rule 6 (statement -> assignation .)
    MAP_TYPE        reduce using rule 6 (statement -> assignation .)
    SET_TYPE        reduce using rule 6 (statement -> assignation .)
    VAR             reduce using rule 6 (statement -> assignation .)
    CONST           reduce using rule 6 (statement -> assignation .)
    FINAL           reduce using rule 6 (statement -> assignation .)
    VOID            reduce using rule 6 (statement -> assignation .)
    INT             reduce using rule 6 (statement -> assignation .)
    DOUBLE          reduce using rule 6 (statement -> assignation .)
    $end            reduce using rule 6 (statement -> assignation .)
    RBRACE          reduce using rule 6 (statement -> assignation .)
    BREAK           reduce using rule 6 (statement -> assignation .)


state 7

    (7) statement -> function .

    ID              reduce using rule 7 (statement -> function .)
    IF              reduce using rule 7 (statement -> function .)
    WHILE           reduce using rule 7 (statement -> function .)
    FOR             reduce using rule 7 (statement -> function .)
    PRINT           reduce using rule 7 (statement -> function .)
    CLASS           reduce using rule 7 (statement -> function .)
    ENUM            reduce using rule 7 (statement -> function .)
    TRY             reduce using rule 7 (statement -> function .)
    SWITCH          reduce using rule 7 (statement -> function .)
    INT_TYPE        reduce using rule 7 (statement -> function .)
    STRING_TYPE     reduce using rule 7 (statement -> function .)
    NUM_TYPE        reduce using rule 7 (statement -> function .)
    DOUBLE_TYPE     reduce using rule 7 (statement -> function .)
    BOOL_TYPE       reduce using rule 7 (statement -> function .)
    LIST_TYPE       reduce using rule 7 (statement -> function .)
    MAP_TYPE        reduce using rule 7 (statement -> function .)
    SET_TYPE        reduce using rule 7 (statement -> function .)
    VAR             reduce using rule 7 (statement -> function .)
    CONST           reduce using rule 7 (statement -> function .)
    FINAL           reduce using rule 7 (statement -> function .)
    VOID            reduce using rule 7 (statement -> function .)
    INT             reduce using rule 7 (statement -> function .)
    DOUBLE          reduce using rule 7 (statement -> function .)
    $end            reduce using rule 7 (statement -> function .)
    RBRACE          reduce using rule 7 (statement -> function .)
    BREAK           reduce using rule 7 (statement -> function .)


state 8

    (8) statement -> if .

    ID              reduce using rule 8 (statement -> if .)
    IF              reduce using rule 8 (statement -> if .)
    WHILE           reduce using rule 8 (statement -> if .)
    FOR             reduce using rule 8 (statement -> if .)
    PRINT           reduce using rule 8 (statement -> if .)
    CLASS           reduce using rule 8 (statement -> if .)
    ENUM            reduce using rule 8 (statement -> if .)
    TRY             reduce using rule 8 (statement -> if .)
    SWITCH          reduce using rule 8 (statement -> if .)
    INT_TYPE        reduce using rule 8 (statement -> if .)
    STRING_TYPE     reduce using rule 8 (statement -> if .)
    NUM_TYPE        reduce using rule 8 (statement -> if .)
    DOUBLE_TYPE     reduce using rule 8 (statement -> if .)
    BOOL_TYPE       reduce using rule 8 (statement -> if .)
    LIST_TYPE       reduce using rule 8 (statement -> if .)
    MAP_TYPE        reduce using rule 8 (statement -> if .)
    SET_TYPE        reduce using rule 8 (statement -> if .)
    VAR             reduce using rule 8 (statement -> if .)
    CONST           reduce using rule 8 (statement -> if .)
    FINAL           reduce using rule 8 (statement -> if .)
    VOID            reduce using rule 8 (statement -> if .)
    INT             reduce using rule 8 (statement -> if .)
    DOUBLE          reduce using rule 8 (statement -> if .)
    $end            reduce using rule 8 (statement -> if .)
    RBRACE          reduce using rule 8 (statement -> if .)
    BREAK           reduce using rule 8 (statement -> if .)


state 9

    (9) statement -> while .

    ID              reduce using rule 9 (statement -> while .)
    IF              reduce using rule 9 (statement -> while .)
    WHILE           reduce using rule 9 (statement -> while .)
    FOR             reduce using rule 9 (statement -> while .)
    PRINT           reduce using rule 9 (statement -> while .)
    CLASS           reduce using rule 9 (statement -> while .)
    ENUM            reduce using rule 9 (statement -> while .)
    TRY             reduce using rule 9 (statement -> while .)
    SWITCH          reduce using rule 9 (statement -> while .)
    INT_TYPE        reduce using rule 9 (statement -> while .)
    STRING_TYPE     reduce using rule 9 (statement -> while .)
    NUM_TYPE        reduce using rule 9 (statement -> while .)
    DOUBLE_TYPE     reduce using rule 9 (statement -> while .)
    BOOL_TYPE       reduce using rule 9 (statement -> while .)
    LIST_TYPE       reduce using rule 9 (statement -> while .)
    MAP_TYPE        reduce using rule 9 (statement -> while .)
    SET_TYPE        reduce using rule 9 (statement -> while .)
    VAR             reduce using rule 9 (statement -> while .)
    CONST           reduce using rule 9 (statement -> while .)
    FINAL           reduce using rule 9 (statement -> while .)
    VOID            reduce using rule 9 (statement -> while .)
    INT             reduce using rule 9 (statement -> while .)
    DOUBLE          reduce using rule 9 (statement -> while .)
    $end            reduce using rule 9 (statement -> while .)
    RBRACE          reduce using rule 9 (statement -> while .)
    BREAK           reduce using rule 9 (statement -> while .)


state 10

    (10) statement -> for .

    ID              reduce using rule 10 (statement -> for .)
    IF              reduce using rule 10 (statement -> for .)
    WHILE           reduce using rule 10 (statement -> for .)
    FOR             reduce using rule 10 (statement -> for .)
    PRINT           reduce using rule 10 (statement -> for .)
    CLASS           reduce using rule 10 (statement -> for .)
    ENUM            reduce using rule 10 (statement -> for .)
    TRY             reduce using rule 10 (statement -> for .)
    SWITCH          reduce using rule 10 (statement -> for .)
    INT_TYPE        reduce using rule 10 (statement -> for .)
    STRING_TYPE     reduce using rule 10 (statement -> for .)
    NUM_TYPE        reduce using rule 10 (statement -> for .)
    DOUBLE_TYPE     reduce using rule 10 (statement -> for .)
    BOOL_TYPE       reduce using rule 10 (statement -> for .)
    LIST_TYPE       reduce using rule 10 (statement -> for .)
    MAP_TYPE        reduce using rule 10 (statement -> for .)
    SET_TYPE        reduce using rule 10 (statement -> for .)
    VAR             reduce using rule 10 (statement -> for .)
    CONST           reduce using rule 10 (statement -> for .)
    FINAL           reduce using rule 10 (statement -> for .)
    VOID            reduce using rule 10 (statement -> for .)
    INT             reduce using rule 10 (statement -> for .)
    DOUBLE          reduce using rule 10 (statement -> for .)
    $end            reduce using rule 10 (statement -> for .)
    RBRACE          reduce using rule 10 (statement -> for .)
    BREAK           reduce using rule 10 (statement -> for .)


state 11

    (11) statement -> print .

    ID              reduce using rule 11 (statement -> print .)
    IF              reduce using rule 11 (statement -> print .)
    WHILE           reduce using rule 11 (statement -> print .)
    FOR             reduce using rule 11 (statement -> print .)
    PRINT           reduce using rule 11 (statement -> print .)
    CLASS           reduce using rule 11 (statement -> print .)
    ENUM            reduce using rule 11 (statement -> print .)
    TRY             reduce using rule 11 (statement -> print .)
    SWITCH          reduce using rule 11 (statement -> print .)
    INT_TYPE        reduce using rule 11 (statement -> print .)
    STRING_TYPE     reduce using rule 11 (statement -> print .)
    NUM_TYPE        reduce using rule 11 (statement -> print .)
    DOUBLE_TYPE     reduce using rule 11 (statement -> print .)
    BOOL_TYPE       reduce using rule 11 (statement -> print .)
    LIST_TYPE       reduce using rule 11 (statement -> print .)
    MAP_TYPE        reduce using rule 11 (statement -> print .)
    SET_TYPE        reduce using rule 11 (statement -> print .)
    VAR             reduce using rule 11 (statement -> print .)
    CONST           reduce using rule 11 (statement -> print .)
    FINAL           reduce using rule 11 (statement -> print .)
    VOID            reduce using rule 11 (statement -> print .)
    INT             reduce using rule 11 (statement -> print .)
    DOUBLE          reduce using rule 11 (statement -> print .)
    $end            reduce using rule 11 (statement -> print .)
    RBRACE          reduce using rule 11 (statement -> print .)
    BREAK           reduce using rule 11 (statement -> print .)


state 12

    (12) statement -> input .

    ID              reduce using rule 12 (statement -> input .)
    IF              reduce using rule 12 (statement -> input .)
    WHILE           reduce using rule 12 (statement -> input .)
    FOR             reduce using rule 12 (statement -> input .)
    PRINT           reduce using rule 12 (statement -> input .)
    CLASS           reduce using rule 12 (statement -> input .)
    ENUM            reduce using rule 12 (statement -> input .)
    TRY             reduce using rule 12 (statement -> input .)
    SWITCH          reduce using rule 12 (statement -> input .)
    INT_TYPE        reduce using rule 12 (statement -> input .)
    STRING_TYPE     reduce using rule 12 (statement -> input .)
    NUM_TYPE        reduce using rule 12 (statement -> input .)
    DOUBLE_TYPE     reduce using rule 12 (statement -> input .)
    BOOL_TYPE       reduce using rule 12 (statement -> input .)
    LIST_TYPE       reduce using rule 12 (statement -> input .)
    MAP_TYPE        reduce using rule 12 (statement -> input .)
    SET_TYPE        reduce using rule 12 (statement -> input .)
    VAR             reduce using rule 12 (statement -> input .)
    CONST           reduce using rule 12 (statement -> input .)
    FINAL           reduce using rule 12 (statement -> input .)
    VOID            reduce using rule 12 (statement -> input .)
    INT             reduce using rule 12 (statement -> input .)
    DOUBLE          reduce using rule 12 (statement -> input .)
    $end            reduce using rule 12 (statement -> input .)
    RBRACE          reduce using rule 12 (statement -> input .)
    BREAK           reduce using rule 12 (statement -> input .)


state 13

    (13) statement -> class_def .

    ID              reduce using rule 13 (statement -> class_def .)
    IF              reduce using rule 13 (statement -> class_def .)
    WHILE           reduce using rule 13 (statement -> class_def .)
    FOR             reduce using rule 13 (statement -> class_def .)
    PRINT           reduce using rule 13 (statement -> class_def .)
    CLASS           reduce using rule 13 (statement -> class_def .)
    ENUM            reduce using rule 13 (statement -> class_def .)
    TRY             reduce using rule 13 (statement -> class_def .)
    SWITCH          reduce using rule 13 (statement -> class_def .)
    INT_TYPE        reduce using rule 13 (statement -> class_def .)
    STRING_TYPE     reduce using rule 13 (statement -> class_def .)
    NUM_TYPE        reduce using rule 13 (statement -> class_def .)
    DOUBLE_TYPE     reduce using rule 13 (statement -> class_def .)
    BOOL_TYPE       reduce using rule 13 (statement -> class_def .)
    LIST_TYPE       reduce using rule 13 (statement -> class_def .)
    MAP_TYPE        reduce using rule 13 (statement -> class_def .)
    SET_TYPE        reduce using rule 13 (statement -> class_def .)
    VAR             reduce using rule 13 (statement -> class_def .)
    CONST           reduce using rule 13 (statement -> class_def .)
    FINAL           reduce using rule 13 (statement -> class_def .)
    VOID            reduce using rule 13 (statement -> class_def .)
    INT             reduce using rule 13 (statement -> class_def .)
    DOUBLE          reduce using rule 13 (statement -> class_def .)
    $end            reduce using rule 13 (statement -> class_def .)
    RBRACE          reduce using rule 13 (statement -> class_def .)
    BREAK           reduce using rule 13 (statement -> class_def .)


state 14

    (14) statement -> enum .

    ID              reduce using rule 14 (statement -> enum .)
    IF              reduce using rule 14 (statement -> enum .)
    WHILE           reduce using rule 14 (statement -> enum .)
    FOR             reduce using rule 14 (statement -> enum .)
    PRINT           reduce using rule 14 (statement -> enum .)
    CLASS           reduce using rule 14 (statement -> enum .)
    ENUM            reduce using rule 14 (statement -> enum .)
    TRY             reduce using rule 14 (statement -> enum .)
    SWITCH          reduce using rule 14 (statement -> enum .)
    INT_TYPE        reduce using rule 14 (statement -> enum .)
    STRING_TYPE     reduce using rule 14 (statement -> enum .)
    NUM_TYPE        reduce using rule 14 (statement -> enum .)
    DOUBLE_TYPE     reduce using rule 14 (statement -> enum .)
    BOOL_TYPE       reduce using rule 14 (statement -> enum .)
    LIST_TYPE       reduce using rule 14 (statement -> enum .)
    MAP_TYPE        reduce using rule 14 (statement -> enum .)
    SET_TYPE        reduce using rule 14 (statement -> enum .)
    VAR             reduce using rule 14 (statement -> enum .)
    CONST           reduce using rule 14 (statement -> enum .)
    FINAL           reduce using rule 14 (statement -> enum .)
    VOID            reduce using rule 14 (statement -> enum .)
    INT             reduce using rule 14 (statement -> enum .)
    DOUBLE          reduce using rule 14 (statement -> enum .)
    $end            reduce using rule 14 (statement -> enum .)
    RBRACE          reduce using rule 14 (statement -> enum .)
    BREAK           reduce using rule 14 (statement -> enum .)


state 15

    (15) statement -> try .

    ID              reduce using rule 15 (statement -> try .)
    IF              reduce using rule 15 (statement -> try .)
    WHILE           reduce using rule 15 (statement -> try .)
    FOR             reduce using rule 15 (statement -> try .)
    PRINT           reduce using rule 15 (statement -> try .)
    CLASS           reduce using rule 15 (statement -> try .)
    ENUM            reduce using rule 15 (statement -> try .)
    TRY             reduce using rule 15 (statement -> try .)
    SWITCH          reduce using rule 15 (statement -> try .)
    INT_TYPE        reduce using rule 15 (statement -> try .)
    STRING_TYPE     reduce using rule 15 (statement -> try .)
    NUM_TYPE        reduce using rule 15 (statement -> try .)
    DOUBLE_TYPE     reduce using rule 15 (statement -> try .)
    BOOL_TYPE       reduce using rule 15 (statement -> try .)
    LIST_TYPE       reduce using rule 15 (statement -> try .)
    MAP_TYPE        reduce using rule 15 (statement -> try .)
    SET_TYPE        reduce using rule 15 (statement -> try .)
    VAR             reduce using rule 15 (statement -> try .)
    CONST           reduce using rule 15 (statement -> try .)
    FINAL           reduce using rule 15 (statement -> try .)
    VOID            reduce using rule 15 (statement -> try .)
    INT             reduce using rule 15 (statement -> try .)
    DOUBLE          reduce using rule 15 (statement -> try .)
    $end            reduce using rule 15 (statement -> try .)
    RBRACE          reduce using rule 15 (statement -> try .)
    BREAK           reduce using rule 15 (statement -> try .)


state 16

    (16) statement -> switch .

    ID              reduce using rule 16 (statement -> switch .)
    IF              reduce using rule 16 (statement -> switch .)
    WHILE           reduce using rule 16 (statement -> switch .)
    FOR             reduce using rule 16 (statement -> switch .)
    PRINT           reduce using rule 16 (statement -> switch .)
    CLASS           reduce using rule 16 (statement -> switch .)
    ENUM            reduce using rule 16 (statement -> switch .)
    TRY             reduce using rule 16 (statement -> switch .)
    SWITCH          reduce using rule 16 (statement -> switch .)
    INT_TYPE        reduce using rule 16 (statement -> switch .)
    STRING_TYPE     reduce using rule 16 (statement -> switch .)
    NUM_TYPE        reduce using rule 16 (statement -> switch .)
    DOUBLE_TYPE     reduce using rule 16 (statement -> switch .)
    BOOL_TYPE       reduce using rule 16 (statement -> switch .)
    LIST_TYPE       reduce using rule 16 (statement -> switch .)
    MAP_TYPE        reduce using rule 16 (statement -> switch .)
    SET_TYPE        reduce using rule 16 (statement -> switch .)
    VAR             reduce using rule 16 (statement -> switch .)
    CONST           reduce using rule 16 (statement -> switch .)
    FINAL           reduce using rule 16 (statement -> switch .)
    VOID            reduce using rule 16 (statement -> switch .)
    INT             reduce using rule 16 (statement -> switch .)
    DOUBLE          reduce using rule 16 (statement -> switch .)
    $end            reduce using rule 16 (statement -> switch .)
    RBRACE          reduce using rule 16 (statement -> switch .)
    BREAK           reduce using rule 16 (statement -> switch .)


state 17

    (17) statement -> empty .

    ID              reduce using rule 17 (statement -> empty .)
    IF              reduce using rule 17 (statement -> empty .)
    WHILE           reduce using rule 17 (statement -> empty .)
    FOR             reduce using rule 17 (statement -> empty .)
    PRINT           reduce using rule 17 (statement -> empty .)
    CLASS           reduce using rule 17 (statement -> empty .)
    ENUM            reduce using rule 17 (statement -> empty .)
    TRY             reduce using rule 17 (statement -> empty .)
    SWITCH          reduce using rule 17 (statement -> empty .)
    INT_TYPE        reduce using rule 17 (statement -> empty .)
    STRING_TYPE     reduce using rule 17 (statement -> empty .)
    NUM_TYPE        reduce using rule 17 (statement -> empty .)
    DOUBLE_TYPE     reduce using rule 17 (statement -> empty .)
    BOOL_TYPE       reduce using rule 17 (statement -> empty .)
    LIST_TYPE       reduce using rule 17 (statement -> empty .)
    MAP_TYPE        reduce using rule 17 (statement -> empty .)
    SET_TYPE        reduce using rule 17 (statement -> empty .)
    VAR             reduce using rule 17 (statement -> empty .)
    CONST           reduce using rule 17 (statement -> empty .)
    FINAL           reduce using rule 17 (statement -> empty .)
    VOID            reduce using rule 17 (statement -> empty .)
    INT             reduce using rule 17 (statement -> empty .)
    DOUBLE          reduce using rule 17 (statement -> empty .)
    $end            reduce using rule 17 (statement -> empty .)
    RBRACE          reduce using rule 17 (statement -> empty .)
    BREAK           reduce using rule 17 (statement -> empty .)


state 18

    (42) expression -> term .
    (43) term -> term . TIMES factor
    (44) term -> term . DIVIDE factor
    (45) term -> term . MODULE factor

    SEMICOLON       reduce using rule 42 (expression -> term .)
    PLUS            reduce using rule 42 (expression -> term .)
    MINUS           reduce using rule 42 (expression -> term .)
    EQUALS          reduce using rule 42 (expression -> term .)
    NOT_EQUALS      reduce using rule 42 (expression -> term .)
    GREATER_THAN    reduce using rule 42 (expression -> term .)
    LESS_THAN       reduce using rule 42 (expression -> term .)
    GREATER_THAN_OR_EQUALS reduce using rule 42 (expression -> term .)
    LESS_THAN_OR_EQUALS reduce using rule 42 (expression -> term .)
    RPARENTHESIS    reduce using rule 42 (expression -> term .)
    AND             reduce using rule 42 (expression -> term .)
    OR              reduce using rule 42 (expression -> term .)
    COLON           reduce using rule 42 (expression -> term .)
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MODULE          shift and go to state 50


state 19

    (18) declaration -> varType . ID SEMICOLON
    (19) assignation -> varType . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> varType . ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> varType . ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON

    ID              shift and go to state 51


state 20

    (20) assignation -> ID . ASSIGN_OPERATOR variable SEMICOLON
    (81) input -> ID . ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON

    ASSIGN_OPERATOR shift and go to state 52


state 21

    (57) if -> IF . LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> IF . LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE

    LPARENTHESIS    shift and go to state 53


state 22

    (59) while -> WHILE . LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE

    LPARENTHESIS    shift and go to state 54


state 23

    (60) for -> FOR . LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> FOR . LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE

    LPARENTHESIS    shift and go to state 55


state 24

    (80) print -> PRINT . LPARENTHESIS expression RPARENTHESIS SEMICOLON

    LPARENTHESIS    shift and go to state 56


state 25

    (82) class_def -> CLASS . ID LBRACE class_members RBRACE

    ID              shift and go to state 57


state 26

    (67) enum -> ENUM . ID LBRACE enum_values RBRACE

    ID              shift and go to state 58


state 27

    (70) try -> TRY . LBRACE statements RBRACE FINALLY LBRACE statements RBRACE

    LBRACE          shift and go to state 59


state 28

    (71) switch -> SWITCH . LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE

    LPARENTHESIS    shift and go to state 60


state 29

    (46) term -> factor .

    TIMES           reduce using rule 46 (term -> factor .)
    DIVIDE          reduce using rule 46 (term -> factor .)
    MODULE          reduce using rule 46 (term -> factor .)
    SEMICOLON       reduce using rule 46 (term -> factor .)
    PLUS            reduce using rule 46 (term -> factor .)
    MINUS           reduce using rule 46 (term -> factor .)
    EQUALS          reduce using rule 46 (term -> factor .)
    NOT_EQUALS      reduce using rule 46 (term -> factor .)
    GREATER_THAN    reduce using rule 46 (term -> factor .)
    LESS_THAN       reduce using rule 46 (term -> factor .)
    GREATER_THAN_OR_EQUALS reduce using rule 46 (term -> factor .)
    LESS_THAN_OR_EQUALS reduce using rule 46 (term -> factor .)
    RPARENTHESIS    reduce using rule 46 (term -> factor .)
    AND             reduce using rule 46 (term -> factor .)
    OR              reduce using rule 46 (term -> factor .)
    COLON           reduce using rule 46 (term -> factor .)


state 30

    (21) varType -> INT_TYPE .

    ID              reduce using rule 21 (varType -> INT_TYPE .)


state 31

    (22) varType -> STRING_TYPE .

    ID              reduce using rule 22 (varType -> STRING_TYPE .)


state 32

    (23) varType -> NUM_TYPE .

    ID              reduce using rule 23 (varType -> NUM_TYPE .)


state 33

    (24) varType -> DOUBLE_TYPE .

    ID              reduce using rule 24 (varType -> DOUBLE_TYPE .)


state 34

    (25) varType -> BOOL_TYPE .

    ID              reduce using rule 25 (varType -> BOOL_TYPE .)


state 35

    (26) varType -> LIST_TYPE .

    ID              reduce using rule 26 (varType -> LIST_TYPE .)


state 36

    (27) varType -> MAP_TYPE .

    ID              reduce using rule 27 (varType -> MAP_TYPE .)


state 37

    (28) varType -> SET_TYPE .

    ID              reduce using rule 28 (varType -> SET_TYPE .)


state 38

    (29) varType -> VAR .

    ID              reduce using rule 29 (varType -> VAR .)


state 39

    (30) varType -> CONST .

    ID              reduce using rule 30 (varType -> CONST .)


state 40

    (31) varType -> FINAL .

    ID              reduce using rule 31 (varType -> FINAL .)


state 41

    (32) varType -> VOID .

    ID              reduce using rule 32 (varType -> VOID .)


state 42

    (47) factor -> INT .

    TIMES           reduce using rule 47 (factor -> INT .)
    DIVIDE          reduce using rule 47 (factor -> INT .)
    MODULE          reduce using rule 47 (factor -> INT .)
    SEMICOLON       reduce using rule 47 (factor -> INT .)
    PLUS            reduce using rule 47 (factor -> INT .)
    MINUS           reduce using rule 47 (factor -> INT .)
    EQUALS          reduce using rule 47 (factor -> INT .)
    NOT_EQUALS      reduce using rule 47 (factor -> INT .)
    GREATER_THAN    reduce using rule 47 (factor -> INT .)
    LESS_THAN       reduce using rule 47 (factor -> INT .)
    GREATER_THAN_OR_EQUALS reduce using rule 47 (factor -> INT .)
    LESS_THAN_OR_EQUALS reduce using rule 47 (factor -> INT .)
    RPARENTHESIS    reduce using rule 47 (factor -> INT .)
    AND             reduce using rule 47 (factor -> INT .)
    OR              reduce using rule 47 (factor -> INT .)
    COLON           reduce using rule 47 (factor -> INT .)


state 43

    (48) factor -> DOUBLE .

    TIMES           reduce using rule 48 (factor -> DOUBLE .)
    DIVIDE          reduce using rule 48 (factor -> DOUBLE .)
    MODULE          reduce using rule 48 (factor -> DOUBLE .)
    SEMICOLON       reduce using rule 48 (factor -> DOUBLE .)
    PLUS            reduce using rule 48 (factor -> DOUBLE .)
    MINUS           reduce using rule 48 (factor -> DOUBLE .)
    EQUALS          reduce using rule 48 (factor -> DOUBLE .)
    NOT_EQUALS      reduce using rule 48 (factor -> DOUBLE .)
    GREATER_THAN    reduce using rule 48 (factor -> DOUBLE .)
    LESS_THAN       reduce using rule 48 (factor -> DOUBLE .)
    GREATER_THAN_OR_EQUALS reduce using rule 48 (factor -> DOUBLE .)
    LESS_THAN_OR_EQUALS reduce using rule 48 (factor -> DOUBLE .)
    RPARENTHESIS    reduce using rule 48 (factor -> DOUBLE .)
    AND             reduce using rule 48 (factor -> DOUBLE .)
    OR              reduce using rule 48 (factor -> DOUBLE .)
    COLON           reduce using rule 48 (factor -> DOUBLE .)


state 44

    (2) statements -> statements statement .

    ID              reduce using rule 2 (statements -> statements statement .)
    IF              reduce using rule 2 (statements -> statements statement .)
    WHILE           reduce using rule 2 (statements -> statements statement .)
    FOR             reduce using rule 2 (statements -> statements statement .)
    PRINT           reduce using rule 2 (statements -> statements statement .)
    CLASS           reduce using rule 2 (statements -> statements statement .)
    ENUM            reduce using rule 2 (statements -> statements statement .)
    TRY             reduce using rule 2 (statements -> statements statement .)
    SWITCH          reduce using rule 2 (statements -> statements statement .)
    INT_TYPE        reduce using rule 2 (statements -> statements statement .)
    STRING_TYPE     reduce using rule 2 (statements -> statements statement .)
    NUM_TYPE        reduce using rule 2 (statements -> statements statement .)
    DOUBLE_TYPE     reduce using rule 2 (statements -> statements statement .)
    BOOL_TYPE       reduce using rule 2 (statements -> statements statement .)
    LIST_TYPE       reduce using rule 2 (statements -> statements statement .)
    MAP_TYPE        reduce using rule 2 (statements -> statements statement .)
    SET_TYPE        reduce using rule 2 (statements -> statements statement .)
    VAR             reduce using rule 2 (statements -> statements statement .)
    CONST           reduce using rule 2 (statements -> statements statement .)
    FINAL           reduce using rule 2 (statements -> statements statement .)
    VOID            reduce using rule 2 (statements -> statements statement .)
    INT             reduce using rule 2 (statements -> statements statement .)
    DOUBLE          reduce using rule 2 (statements -> statements statement .)
    $end            reduce using rule 2 (statements -> statements statement .)
    RBRACE          reduce using rule 2 (statements -> statements statement .)
    BREAK           reduce using rule 2 (statements -> statements statement .)


state 45

    (4) statement -> expression SEMICOLON .

    ID              reduce using rule 4 (statement -> expression SEMICOLON .)
    IF              reduce using rule 4 (statement -> expression SEMICOLON .)
    WHILE           reduce using rule 4 (statement -> expression SEMICOLON .)
    FOR             reduce using rule 4 (statement -> expression SEMICOLON .)
    PRINT           reduce using rule 4 (statement -> expression SEMICOLON .)
    CLASS           reduce using rule 4 (statement -> expression SEMICOLON .)
    ENUM            reduce using rule 4 (statement -> expression SEMICOLON .)
    TRY             reduce using rule 4 (statement -> expression SEMICOLON .)
    SWITCH          reduce using rule 4 (statement -> expression SEMICOLON .)
    INT_TYPE        reduce using rule 4 (statement -> expression SEMICOLON .)
    STRING_TYPE     reduce using rule 4 (statement -> expression SEMICOLON .)
    NUM_TYPE        reduce using rule 4 (statement -> expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 4 (statement -> expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 4 (statement -> expression SEMICOLON .)
    LIST_TYPE       reduce using rule 4 (statement -> expression SEMICOLON .)
    MAP_TYPE        reduce using rule 4 (statement -> expression SEMICOLON .)
    SET_TYPE        reduce using rule 4 (statement -> expression SEMICOLON .)
    VAR             reduce using rule 4 (statement -> expression SEMICOLON .)
    CONST           reduce using rule 4 (statement -> expression SEMICOLON .)
    FINAL           reduce using rule 4 (statement -> expression SEMICOLON .)
    VOID            reduce using rule 4 (statement -> expression SEMICOLON .)
    INT             reduce using rule 4 (statement -> expression SEMICOLON .)
    DOUBLE          reduce using rule 4 (statement -> expression SEMICOLON .)
    $end            reduce using rule 4 (statement -> expression SEMICOLON .)
    RBRACE          reduce using rule 4 (statement -> expression SEMICOLON .)
    BREAK           reduce using rule 4 (statement -> expression SEMICOLON .)


state 46

    (40) expression -> expression PLUS . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

    term                           shift and go to state 61
    factor                         shift and go to state 29

state 47

    (41) expression -> expression MINUS . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

    term                           shift and go to state 62
    factor                         shift and go to state 29

state 48

    (43) term -> term TIMES . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

    factor                         shift and go to state 63

state 49

    (44) term -> term DIVIDE . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

    factor                         shift and go to state 64

state 50

    (45) term -> term MODULE . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

    factor                         shift and go to state 65

state 51

    (18) declaration -> varType ID . SEMICOLON
    (19) assignation -> varType ID . ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> varType ID . LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> varType ID . LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON

    SEMICOLON       shift and go to state 66
    ASSIGN_OPERATOR shift and go to state 67
    LPARENTHESIS    shift and go to state 68


state 52

    (20) assignation -> ID ASSIGN_OPERATOR . variable SEMICOLON
    (81) input -> ID ASSIGN_OPERATOR . STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    STDIN           shift and go to state 71
    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    variable                       shift and go to state 70
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 53

    (57) if -> IF LPARENTHESIS . booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> IF LPARENTHESIS . booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (49) booleanExpression -> . variable EQUALS variable
    (50) booleanExpression -> . variable NOT_EQUALS variable
    (51) booleanExpression -> . variable GREATER_THAN variable
    (52) booleanExpression -> . variable LESS_THAN variable
    (53) booleanExpression -> . variable GREATER_THAN_OR_EQUALS variable
    (54) booleanExpression -> . variable LESS_THAN_OR_EQUALS variable
    (55) booleanExpression -> . booleanExpression AND booleanExpression
    (56) booleanExpression -> . booleanExpression OR booleanExpression
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    booleanExpression              shift and go to state 78
    variable                       shift and go to state 79
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 54

    (59) while -> WHILE LPARENTHESIS . booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (49) booleanExpression -> . variable EQUALS variable
    (50) booleanExpression -> . variable NOT_EQUALS variable
    (51) booleanExpression -> . variable GREATER_THAN variable
    (52) booleanExpression -> . variable LESS_THAN variable
    (53) booleanExpression -> . variable GREATER_THAN_OR_EQUALS variable
    (54) booleanExpression -> . variable LESS_THAN_OR_EQUALS variable
    (55) booleanExpression -> . booleanExpression AND booleanExpression
    (56) booleanExpression -> . booleanExpression OR booleanExpression
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    booleanExpression              shift and go to state 80
    variable                       shift and go to state 79
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 55

    (60) for -> FOR LPARENTHESIS . assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> FOR LPARENTHESIS . assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID

    ID              shift and go to state 83
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41

    assignation                    shift and go to state 81
    varType                        shift and go to state 82

state 56

    (80) print -> PRINT LPARENTHESIS . expression RPARENTHESIS SEMICOLON
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

    expression                     shift and go to state 84
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 57

    (82) class_def -> CLASS ID . LBRACE class_members RBRACE

    LBRACE          shift and go to state 85


state 58

    (67) enum -> ENUM ID . LBRACE enum_values RBRACE

    LBRACE          shift and go to state 86


state 59

    (70) try -> TRY LBRACE . statements RBRACE FINALLY LBRACE statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    RBRACE          reduce using rule 87 (empty -> .)
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    statements                     shift and go to state 87
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 60

    (71) switch -> SWITCH LPARENTHESIS . variable RPARENTHESIS LBRACE cases default_case RBRACE
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    variable                       shift and go to state 88
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 61

    (40) expression -> expression PLUS term .
    (43) term -> term . TIMES factor
    (44) term -> term . DIVIDE factor
    (45) term -> term . MODULE factor

    SEMICOLON       reduce using rule 40 (expression -> expression PLUS term .)
    PLUS            reduce using rule 40 (expression -> expression PLUS term .)
    MINUS           reduce using rule 40 (expression -> expression PLUS term .)
    EQUALS          reduce using rule 40 (expression -> expression PLUS term .)
    NOT_EQUALS      reduce using rule 40 (expression -> expression PLUS term .)
    GREATER_THAN    reduce using rule 40 (expression -> expression PLUS term .)
    LESS_THAN       reduce using rule 40 (expression -> expression PLUS term .)
    GREATER_THAN_OR_EQUALS reduce using rule 40 (expression -> expression PLUS term .)
    LESS_THAN_OR_EQUALS reduce using rule 40 (expression -> expression PLUS term .)
    RPARENTHESIS    reduce using rule 40 (expression -> expression PLUS term .)
    AND             reduce using rule 40 (expression -> expression PLUS term .)
    OR              reduce using rule 40 (expression -> expression PLUS term .)
    COLON           reduce using rule 40 (expression -> expression PLUS term .)
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MODULE          shift and go to state 50


state 62

    (41) expression -> expression MINUS term .
    (43) term -> term . TIMES factor
    (44) term -> term . DIVIDE factor
    (45) term -> term . MODULE factor

    SEMICOLON       reduce using rule 41 (expression -> expression MINUS term .)
    PLUS            reduce using rule 41 (expression -> expression MINUS term .)
    MINUS           reduce using rule 41 (expression -> expression MINUS term .)
    EQUALS          reduce using rule 41 (expression -> expression MINUS term .)
    NOT_EQUALS      reduce using rule 41 (expression -> expression MINUS term .)
    GREATER_THAN    reduce using rule 41 (expression -> expression MINUS term .)
    LESS_THAN       reduce using rule 41 (expression -> expression MINUS term .)
    GREATER_THAN_OR_EQUALS reduce using rule 41 (expression -> expression MINUS term .)
    LESS_THAN_OR_EQUALS reduce using rule 41 (expression -> expression MINUS term .)
    RPARENTHESIS    reduce using rule 41 (expression -> expression MINUS term .)
    AND             reduce using rule 41 (expression -> expression MINUS term .)
    OR              reduce using rule 41 (expression -> expression MINUS term .)
    COLON           reduce using rule 41 (expression -> expression MINUS term .)
    TIMES           shift and go to state 48
    DIVIDE          shift and go to state 49
    MODULE          shift and go to state 50


state 63

    (43) term -> term TIMES factor .

    TIMES           reduce using rule 43 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 43 (term -> term TIMES factor .)
    MODULE          reduce using rule 43 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 43 (term -> term TIMES factor .)
    PLUS            reduce using rule 43 (term -> term TIMES factor .)
    MINUS           reduce using rule 43 (term -> term TIMES factor .)
    EQUALS          reduce using rule 43 (term -> term TIMES factor .)
    NOT_EQUALS      reduce using rule 43 (term -> term TIMES factor .)
    GREATER_THAN    reduce using rule 43 (term -> term TIMES factor .)
    LESS_THAN       reduce using rule 43 (term -> term TIMES factor .)
    GREATER_THAN_OR_EQUALS reduce using rule 43 (term -> term TIMES factor .)
    LESS_THAN_OR_EQUALS reduce using rule 43 (term -> term TIMES factor .)
    RPARENTHESIS    reduce using rule 43 (term -> term TIMES factor .)
    AND             reduce using rule 43 (term -> term TIMES factor .)
    OR              reduce using rule 43 (term -> term TIMES factor .)
    COLON           reduce using rule 43 (term -> term TIMES factor .)


state 64

    (44) term -> term DIVIDE factor .

    TIMES           reduce using rule 44 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 44 (term -> term DIVIDE factor .)
    MODULE          reduce using rule 44 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 44 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 44 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 44 (term -> term DIVIDE factor .)
    EQUALS          reduce using rule 44 (term -> term DIVIDE factor .)
    NOT_EQUALS      reduce using rule 44 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 44 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 44 (term -> term DIVIDE factor .)
    GREATER_THAN_OR_EQUALS reduce using rule 44 (term -> term DIVIDE factor .)
    LESS_THAN_OR_EQUALS reduce using rule 44 (term -> term DIVIDE factor .)
    RPARENTHESIS    reduce using rule 44 (term -> term DIVIDE factor .)
    AND             reduce using rule 44 (term -> term DIVIDE factor .)
    OR              reduce using rule 44 (term -> term DIVIDE factor .)
    COLON           reduce using rule 44 (term -> term DIVIDE factor .)


state 65

    (45) term -> term MODULE factor .

    TIMES           reduce using rule 45 (term -> term MODULE factor .)
    DIVIDE          reduce using rule 45 (term -> term MODULE factor .)
    MODULE          reduce using rule 45 (term -> term MODULE factor .)
    SEMICOLON       reduce using rule 45 (term -> term MODULE factor .)
    PLUS            reduce using rule 45 (term -> term MODULE factor .)
    MINUS           reduce using rule 45 (term -> term MODULE factor .)
    EQUALS          reduce using rule 45 (term -> term MODULE factor .)
    NOT_EQUALS      reduce using rule 45 (term -> term MODULE factor .)
    GREATER_THAN    reduce using rule 45 (term -> term MODULE factor .)
    LESS_THAN       reduce using rule 45 (term -> term MODULE factor .)
    GREATER_THAN_OR_EQUALS reduce using rule 45 (term -> term MODULE factor .)
    LESS_THAN_OR_EQUALS reduce using rule 45 (term -> term MODULE factor .)
    RPARENTHESIS    reduce using rule 45 (term -> term MODULE factor .)
    AND             reduce using rule 45 (term -> term MODULE factor .)
    OR              reduce using rule 45 (term -> term MODULE factor .)
    COLON           reduce using rule 45 (term -> term MODULE factor .)


state 66

    (18) declaration -> varType ID SEMICOLON .

    ID              reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    IF              reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    WHILE           reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    FOR             reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    PRINT           reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    CLASS           reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    ENUM            reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    TRY             reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    SWITCH          reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    INT_TYPE        reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    STRING_TYPE     reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    NUM_TYPE        reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    BOOL_TYPE       reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    LIST_TYPE       reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    MAP_TYPE        reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    SET_TYPE        reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    VAR             reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    CONST           reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    FINAL           reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    VOID            reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    INT             reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    DOUBLE          reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    $end            reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    RBRACE          reduce using rule 18 (declaration -> varType ID SEMICOLON .)
    BREAK           reduce using rule 18 (declaration -> varType ID SEMICOLON .)


state 67

    (19) assignation -> varType ID ASSIGN_OPERATOR . variable SEMICOLON
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    variable                       shift and go to state 89
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 68

    (64) function -> varType ID LPARENTHESIS . parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> varType ID LPARENTHESIS . parameters RPARENTHESIS ARROW expression SEMICOLON
    (76) parameters -> . parameters COMMA parameter
    (77) parameters -> . parameter
    (78) parameters -> . empty
    (79) parameter -> . varType ID
    (87) empty -> .
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID

    RPARENTHESIS    reduce using rule 87 (empty -> .)
    COMMA           reduce using rule 87 (empty -> .)
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41

    varType                        shift and go to state 90
    parameters                     shift and go to state 91
    parameter                      shift and go to state 92
    empty                          shift and go to state 93

state 69

    (38) variable -> ID .

    SEMICOLON       reduce using rule 38 (variable -> ID .)
    EQUALS          reduce using rule 38 (variable -> ID .)
    NOT_EQUALS      reduce using rule 38 (variable -> ID .)
    GREATER_THAN    reduce using rule 38 (variable -> ID .)
    LESS_THAN       reduce using rule 38 (variable -> ID .)
    GREATER_THAN_OR_EQUALS reduce using rule 38 (variable -> ID .)
    LESS_THAN_OR_EQUALS reduce using rule 38 (variable -> ID .)
    RPARENTHESIS    reduce using rule 38 (variable -> ID .)
    AND             reduce using rule 38 (variable -> ID .)
    OR              reduce using rule 38 (variable -> ID .)
    COLON           reduce using rule 38 (variable -> ID .)


state 70

    (20) assignation -> ID ASSIGN_OPERATOR variable . SEMICOLON

    SEMICOLON       shift and go to state 94


state 71

    (81) input -> ID ASSIGN_OPERATOR STDIN . DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON

    DOT             shift and go to state 95


state 72

    (33) variable -> INT .
    (47) factor -> INT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 33 (variable -> INT .)
  ! reduce/reduce conflict for EQUALS resolved using rule 33 (variable -> INT .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 33 (variable -> INT .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 33 (variable -> INT .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 33 (variable -> INT .)
  ! reduce/reduce conflict for GREATER_THAN_OR_EQUALS resolved using rule 33 (variable -> INT .)
  ! reduce/reduce conflict for LESS_THAN_OR_EQUALS resolved using rule 33 (variable -> INT .)
  ! reduce/reduce conflict for RPARENTHESIS resolved using rule 33 (variable -> INT .)
  ! reduce/reduce conflict for AND resolved using rule 33 (variable -> INT .)
  ! reduce/reduce conflict for OR resolved using rule 33 (variable -> INT .)
  ! reduce/reduce conflict for COLON resolved using rule 33 (variable -> INT .)
    SEMICOLON       reduce using rule 33 (variable -> INT .)
    EQUALS          reduce using rule 33 (variable -> INT .)
    NOT_EQUALS      reduce using rule 33 (variable -> INT .)
    GREATER_THAN    reduce using rule 33 (variable -> INT .)
    LESS_THAN       reduce using rule 33 (variable -> INT .)
    GREATER_THAN_OR_EQUALS reduce using rule 33 (variable -> INT .)
    LESS_THAN_OR_EQUALS reduce using rule 33 (variable -> INT .)
    RPARENTHESIS    reduce using rule 33 (variable -> INT .)
    AND             reduce using rule 33 (variable -> INT .)
    OR              reduce using rule 33 (variable -> INT .)
    COLON           reduce using rule 33 (variable -> INT .)
    TIMES           reduce using rule 47 (factor -> INT .)
    DIVIDE          reduce using rule 47 (factor -> INT .)
    MODULE          reduce using rule 47 (factor -> INT .)
    PLUS            reduce using rule 47 (factor -> INT .)
    MINUS           reduce using rule 47 (factor -> INT .)

  ! SEMICOLON       [ reduce using rule 47 (factor -> INT .) ]
  ! EQUALS          [ reduce using rule 47 (factor -> INT .) ]
  ! NOT_EQUALS      [ reduce using rule 47 (factor -> INT .) ]
  ! GREATER_THAN    [ reduce using rule 47 (factor -> INT .) ]
  ! LESS_THAN       [ reduce using rule 47 (factor -> INT .) ]
  ! GREATER_THAN_OR_EQUALS [ reduce using rule 47 (factor -> INT .) ]
  ! LESS_THAN_OR_EQUALS [ reduce using rule 47 (factor -> INT .) ]
  ! RPARENTHESIS    [ reduce using rule 47 (factor -> INT .) ]
  ! AND             [ reduce using rule 47 (factor -> INT .) ]
  ! OR              [ reduce using rule 47 (factor -> INT .) ]
  ! COLON           [ reduce using rule 47 (factor -> INT .) ]


state 73

    (34) variable -> DOUBLE .
    (48) factor -> DOUBLE .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 34 (variable -> DOUBLE .)
  ! reduce/reduce conflict for EQUALS resolved using rule 34 (variable -> DOUBLE .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 34 (variable -> DOUBLE .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 34 (variable -> DOUBLE .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 34 (variable -> DOUBLE .)
  ! reduce/reduce conflict for GREATER_THAN_OR_EQUALS resolved using rule 34 (variable -> DOUBLE .)
  ! reduce/reduce conflict for LESS_THAN_OR_EQUALS resolved using rule 34 (variable -> DOUBLE .)
  ! reduce/reduce conflict for RPARENTHESIS resolved using rule 34 (variable -> DOUBLE .)
  ! reduce/reduce conflict for AND resolved using rule 34 (variable -> DOUBLE .)
  ! reduce/reduce conflict for OR resolved using rule 34 (variable -> DOUBLE .)
  ! reduce/reduce conflict for COLON resolved using rule 34 (variable -> DOUBLE .)
    SEMICOLON       reduce using rule 34 (variable -> DOUBLE .)
    EQUALS          reduce using rule 34 (variable -> DOUBLE .)
    NOT_EQUALS      reduce using rule 34 (variable -> DOUBLE .)
    GREATER_THAN    reduce using rule 34 (variable -> DOUBLE .)
    LESS_THAN       reduce using rule 34 (variable -> DOUBLE .)
    GREATER_THAN_OR_EQUALS reduce using rule 34 (variable -> DOUBLE .)
    LESS_THAN_OR_EQUALS reduce using rule 34 (variable -> DOUBLE .)
    RPARENTHESIS    reduce using rule 34 (variable -> DOUBLE .)
    AND             reduce using rule 34 (variable -> DOUBLE .)
    OR              reduce using rule 34 (variable -> DOUBLE .)
    COLON           reduce using rule 34 (variable -> DOUBLE .)
    TIMES           reduce using rule 48 (factor -> DOUBLE .)
    DIVIDE          reduce using rule 48 (factor -> DOUBLE .)
    MODULE          reduce using rule 48 (factor -> DOUBLE .)
    PLUS            reduce using rule 48 (factor -> DOUBLE .)
    MINUS           reduce using rule 48 (factor -> DOUBLE .)

  ! SEMICOLON       [ reduce using rule 48 (factor -> DOUBLE .) ]
  ! EQUALS          [ reduce using rule 48 (factor -> DOUBLE .) ]
  ! NOT_EQUALS      [ reduce using rule 48 (factor -> DOUBLE .) ]
  ! GREATER_THAN    [ reduce using rule 48 (factor -> DOUBLE .) ]
  ! LESS_THAN       [ reduce using rule 48 (factor -> DOUBLE .) ]
  ! GREATER_THAN_OR_EQUALS [ reduce using rule 48 (factor -> DOUBLE .) ]
  ! LESS_THAN_OR_EQUALS [ reduce using rule 48 (factor -> DOUBLE .) ]
  ! RPARENTHESIS    [ reduce using rule 48 (factor -> DOUBLE .) ]
  ! AND             [ reduce using rule 48 (factor -> DOUBLE .) ]
  ! OR              [ reduce using rule 48 (factor -> DOUBLE .) ]
  ! COLON           [ reduce using rule 48 (factor -> DOUBLE .) ]


state 74

    (35) variable -> STRING .

    SEMICOLON       reduce using rule 35 (variable -> STRING .)
    EQUALS          reduce using rule 35 (variable -> STRING .)
    NOT_EQUALS      reduce using rule 35 (variable -> STRING .)
    GREATER_THAN    reduce using rule 35 (variable -> STRING .)
    LESS_THAN       reduce using rule 35 (variable -> STRING .)
    GREATER_THAN_OR_EQUALS reduce using rule 35 (variable -> STRING .)
    LESS_THAN_OR_EQUALS reduce using rule 35 (variable -> STRING .)
    RPARENTHESIS    reduce using rule 35 (variable -> STRING .)
    AND             reduce using rule 35 (variable -> STRING .)
    OR              reduce using rule 35 (variable -> STRING .)
    COLON           reduce using rule 35 (variable -> STRING .)


state 75

    (36) variable -> BOOL .

    SEMICOLON       reduce using rule 36 (variable -> BOOL .)
    EQUALS          reduce using rule 36 (variable -> BOOL .)
    NOT_EQUALS      reduce using rule 36 (variable -> BOOL .)
    GREATER_THAN    reduce using rule 36 (variable -> BOOL .)
    LESS_THAN       reduce using rule 36 (variable -> BOOL .)
    GREATER_THAN_OR_EQUALS reduce using rule 36 (variable -> BOOL .)
    LESS_THAN_OR_EQUALS reduce using rule 36 (variable -> BOOL .)
    RPARENTHESIS    reduce using rule 36 (variable -> BOOL .)
    AND             reduce using rule 36 (variable -> BOOL .)
    OR              reduce using rule 36 (variable -> BOOL .)
    COLON           reduce using rule 36 (variable -> BOOL .)


state 76

    (37) variable -> NULL .

    SEMICOLON       reduce using rule 37 (variable -> NULL .)
    EQUALS          reduce using rule 37 (variable -> NULL .)
    NOT_EQUALS      reduce using rule 37 (variable -> NULL .)
    GREATER_THAN    reduce using rule 37 (variable -> NULL .)
    LESS_THAN       reduce using rule 37 (variable -> NULL .)
    GREATER_THAN_OR_EQUALS reduce using rule 37 (variable -> NULL .)
    LESS_THAN_OR_EQUALS reduce using rule 37 (variable -> NULL .)
    RPARENTHESIS    reduce using rule 37 (variable -> NULL .)
    AND             reduce using rule 37 (variable -> NULL .)
    OR              reduce using rule 37 (variable -> NULL .)
    COLON           reduce using rule 37 (variable -> NULL .)


state 77

    (39) variable -> expression .
    (40) expression -> expression . PLUS term
    (41) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 39 (variable -> expression .)
    EQUALS          reduce using rule 39 (variable -> expression .)
    NOT_EQUALS      reduce using rule 39 (variable -> expression .)
    GREATER_THAN    reduce using rule 39 (variable -> expression .)
    LESS_THAN       reduce using rule 39 (variable -> expression .)
    GREATER_THAN_OR_EQUALS reduce using rule 39 (variable -> expression .)
    LESS_THAN_OR_EQUALS reduce using rule 39 (variable -> expression .)
    RPARENTHESIS    reduce using rule 39 (variable -> expression .)
    AND             reduce using rule 39 (variable -> expression .)
    OR              reduce using rule 39 (variable -> expression .)
    COLON           reduce using rule 39 (variable -> expression .)
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47


state 78

    (57) if -> IF LPARENTHESIS booleanExpression . RPARENTHESIS LBRACE statements RBRACE
    (58) if -> IF LPARENTHESIS booleanExpression . RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (55) booleanExpression -> booleanExpression . AND booleanExpression
    (56) booleanExpression -> booleanExpression . OR booleanExpression

    RPARENTHESIS    shift and go to state 96
    AND             shift and go to state 97
    OR              shift and go to state 98


state 79

    (49) booleanExpression -> variable . EQUALS variable
    (50) booleanExpression -> variable . NOT_EQUALS variable
    (51) booleanExpression -> variable . GREATER_THAN variable
    (52) booleanExpression -> variable . LESS_THAN variable
    (53) booleanExpression -> variable . GREATER_THAN_OR_EQUALS variable
    (54) booleanExpression -> variable . LESS_THAN_OR_EQUALS variable

    EQUALS          shift and go to state 99
    NOT_EQUALS      shift and go to state 100
    GREATER_THAN    shift and go to state 101
    LESS_THAN       shift and go to state 102
    GREATER_THAN_OR_EQUALS shift and go to state 103
    LESS_THAN_OR_EQUALS shift and go to state 104


state 80

    (59) while -> WHILE LPARENTHESIS booleanExpression . RPARENTHESIS LBRACE statements RBRACE
    (55) booleanExpression -> booleanExpression . AND booleanExpression
    (56) booleanExpression -> booleanExpression . OR booleanExpression

    RPARENTHESIS    shift and go to state 105
    AND             shift and go to state 97
    OR              shift and go to state 98


state 81

    (60) for -> FOR LPARENTHESIS assignation . booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> FOR LPARENTHESIS assignation . booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (49) booleanExpression -> . variable EQUALS variable
    (50) booleanExpression -> . variable NOT_EQUALS variable
    (51) booleanExpression -> . variable GREATER_THAN variable
    (52) booleanExpression -> . variable LESS_THAN variable
    (53) booleanExpression -> . variable GREATER_THAN_OR_EQUALS variable
    (54) booleanExpression -> . variable LESS_THAN_OR_EQUALS variable
    (55) booleanExpression -> . booleanExpression AND booleanExpression
    (56) booleanExpression -> . booleanExpression OR booleanExpression
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    booleanExpression              shift and go to state 106
    variable                       shift and go to state 79
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 82

    (19) assignation -> varType . ID ASSIGN_OPERATOR variable SEMICOLON

    ID              shift and go to state 107


state 83

    (20) assignation -> ID . ASSIGN_OPERATOR variable SEMICOLON

    ASSIGN_OPERATOR shift and go to state 108


state 84

    (80) print -> PRINT LPARENTHESIS expression . RPARENTHESIS SEMICOLON
    (40) expression -> expression . PLUS term
    (41) expression -> expression . MINUS term

    RPARENTHESIS    shift and go to state 109
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47


state 85

    (82) class_def -> CLASS ID LBRACE . class_members RBRACE
    (83) class_members -> . class_members class_member
    (84) class_members -> . class_member
    (85) class_member -> . varType ID SEMICOLON
    (86) class_member -> . function
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON

    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41

    class_members                  shift and go to state 110
    class_member                   shift and go to state 111
    varType                        shift and go to state 112
    function                       shift and go to state 113

state 86

    (67) enum -> ENUM ID LBRACE . enum_values RBRACE
    (68) enum_values -> . enum_values COMMA ID
    (69) enum_values -> . ID

    ID              shift and go to state 114

    enum_values                    shift and go to state 115

state 87

    (70) try -> TRY LBRACE statements . RBRACE FINALLY LBRACE statements RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 116
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! RBRACE          [ reduce using rule 87 (empty -> .) ]
  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    statement                      shift and go to state 44
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 88

    (71) switch -> SWITCH LPARENTHESIS variable . RPARENTHESIS LBRACE cases default_case RBRACE

    RPARENTHESIS    shift and go to state 117


state 89

    (19) assignation -> varType ID ASSIGN_OPERATOR variable . SEMICOLON

    SEMICOLON       shift and go to state 118


state 90

    (79) parameter -> varType . ID

    ID              shift and go to state 119


state 91

    (64) function -> varType ID LPARENTHESIS parameters . RPARENTHESIS LBRACE statements RBRACE
    (65) function -> varType ID LPARENTHESIS parameters . RPARENTHESIS ARROW expression SEMICOLON
    (76) parameters -> parameters . COMMA parameter

    RPARENTHESIS    shift and go to state 120
    COMMA           shift and go to state 121


state 92

    (77) parameters -> parameter .

    RPARENTHESIS    reduce using rule 77 (parameters -> parameter .)
    COMMA           reduce using rule 77 (parameters -> parameter .)


state 93

    (78) parameters -> empty .

    RPARENTHESIS    reduce using rule 78 (parameters -> empty .)
    COMMA           reduce using rule 78 (parameters -> empty .)


state 94

    (20) assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .

    ID              reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    IF              reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    WHILE           reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    FOR             reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    PRINT           reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    CLASS           reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    ENUM            reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    TRY             reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    SWITCH          reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    INT_TYPE        reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    STRING_TYPE     reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    NUM_TYPE        reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    BOOL_TYPE       reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    LIST_TYPE       reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    MAP_TYPE        reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    SET_TYPE        reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    VAR             reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    CONST           reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    FINAL           reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    VOID            reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    INT             reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    DOUBLE          reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    $end            reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    STRING          reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    BOOL            reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    NULL            reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    RBRACE          reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    BREAK           reduce using rule 20 (assignation -> ID ASSIGN_OPERATOR variable SEMICOLON .)


state 95

    (81) input -> ID ASSIGN_OPERATOR STDIN DOT . READ LPARENTHESIS RPARENTHESIS SEMICOLON

    READ            shift and go to state 122


state 96

    (57) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS . LBRACE statements RBRACE
    (58) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS . LBRACE statements RBRACE ELSE LBRACE statements RBRACE

    LBRACE          shift and go to state 123


state 97

    (55) booleanExpression -> booleanExpression AND . booleanExpression
    (49) booleanExpression -> . variable EQUALS variable
    (50) booleanExpression -> . variable NOT_EQUALS variable
    (51) booleanExpression -> . variable GREATER_THAN variable
    (52) booleanExpression -> . variable LESS_THAN variable
    (53) booleanExpression -> . variable GREATER_THAN_OR_EQUALS variable
    (54) booleanExpression -> . variable LESS_THAN_OR_EQUALS variable
    (55) booleanExpression -> . booleanExpression AND booleanExpression
    (56) booleanExpression -> . booleanExpression OR booleanExpression
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    booleanExpression              shift and go to state 124
    variable                       shift and go to state 79
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 98

    (56) booleanExpression -> booleanExpression OR . booleanExpression
    (49) booleanExpression -> . variable EQUALS variable
    (50) booleanExpression -> . variable NOT_EQUALS variable
    (51) booleanExpression -> . variable GREATER_THAN variable
    (52) booleanExpression -> . variable LESS_THAN variable
    (53) booleanExpression -> . variable GREATER_THAN_OR_EQUALS variable
    (54) booleanExpression -> . variable LESS_THAN_OR_EQUALS variable
    (55) booleanExpression -> . booleanExpression AND booleanExpression
    (56) booleanExpression -> . booleanExpression OR booleanExpression
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    booleanExpression              shift and go to state 125
    variable                       shift and go to state 79
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 99

    (49) booleanExpression -> variable EQUALS . variable
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    variable                       shift and go to state 126
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 100

    (50) booleanExpression -> variable NOT_EQUALS . variable
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    variable                       shift and go to state 127
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 101

    (51) booleanExpression -> variable GREATER_THAN . variable
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    variable                       shift and go to state 128
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 102

    (52) booleanExpression -> variable LESS_THAN . variable
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    variable                       shift and go to state 129
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 103

    (53) booleanExpression -> variable GREATER_THAN_OR_EQUALS . variable
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    variable                       shift and go to state 130
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 104

    (54) booleanExpression -> variable LESS_THAN_OR_EQUALS . variable
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    variable                       shift and go to state 131
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 105

    (59) while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS . LBRACE statements RBRACE

    LBRACE          shift and go to state 132


state 106

    (60) for -> FOR LPARENTHESIS assignation booleanExpression . SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> FOR LPARENTHESIS assignation booleanExpression . SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (55) booleanExpression -> booleanExpression . AND booleanExpression
    (56) booleanExpression -> booleanExpression . OR booleanExpression

    SEMICOLON       shift and go to state 133
    AND             shift and go to state 97
    OR              shift and go to state 98


state 107

    (19) assignation -> varType ID . ASSIGN_OPERATOR variable SEMICOLON

    ASSIGN_OPERATOR shift and go to state 67


state 108

    (20) assignation -> ID ASSIGN_OPERATOR . variable SEMICOLON
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    variable                       shift and go to state 70
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 109

    (80) print -> PRINT LPARENTHESIS expression RPARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 134


state 110

    (82) class_def -> CLASS ID LBRACE class_members . RBRACE
    (83) class_members -> class_members . class_member
    (85) class_member -> . varType ID SEMICOLON
    (86) class_member -> . function
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON

    RBRACE          shift and go to state 135
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41

    class_member                   shift and go to state 136
    varType                        shift and go to state 112
    function                       shift and go to state 113

state 111

    (84) class_members -> class_member .

    RBRACE          reduce using rule 84 (class_members -> class_member .)
    INT_TYPE        reduce using rule 84 (class_members -> class_member .)
    STRING_TYPE     reduce using rule 84 (class_members -> class_member .)
    NUM_TYPE        reduce using rule 84 (class_members -> class_member .)
    DOUBLE_TYPE     reduce using rule 84 (class_members -> class_member .)
    BOOL_TYPE       reduce using rule 84 (class_members -> class_member .)
    LIST_TYPE       reduce using rule 84 (class_members -> class_member .)
    MAP_TYPE        reduce using rule 84 (class_members -> class_member .)
    SET_TYPE        reduce using rule 84 (class_members -> class_member .)
    VAR             reduce using rule 84 (class_members -> class_member .)
    CONST           reduce using rule 84 (class_members -> class_member .)
    FINAL           reduce using rule 84 (class_members -> class_member .)
    VOID            reduce using rule 84 (class_members -> class_member .)


state 112

    (85) class_member -> varType . ID SEMICOLON
    (64) function -> varType . ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> varType . ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON

    ID              shift and go to state 137


state 113

    (86) class_member -> function .

    RBRACE          reduce using rule 86 (class_member -> function .)
    INT_TYPE        reduce using rule 86 (class_member -> function .)
    STRING_TYPE     reduce using rule 86 (class_member -> function .)
    NUM_TYPE        reduce using rule 86 (class_member -> function .)
    DOUBLE_TYPE     reduce using rule 86 (class_member -> function .)
    BOOL_TYPE       reduce using rule 86 (class_member -> function .)
    LIST_TYPE       reduce using rule 86 (class_member -> function .)
    MAP_TYPE        reduce using rule 86 (class_member -> function .)
    SET_TYPE        reduce using rule 86 (class_member -> function .)
    VAR             reduce using rule 86 (class_member -> function .)
    CONST           reduce using rule 86 (class_member -> function .)
    FINAL           reduce using rule 86 (class_member -> function .)
    VOID            reduce using rule 86 (class_member -> function .)


state 114

    (69) enum_values -> ID .

    RBRACE          reduce using rule 69 (enum_values -> ID .)
    COMMA           reduce using rule 69 (enum_values -> ID .)


state 115

    (67) enum -> ENUM ID LBRACE enum_values . RBRACE
    (68) enum_values -> enum_values . COMMA ID

    RBRACE          shift and go to state 138
    COMMA           shift and go to state 139


state 116

    (70) try -> TRY LBRACE statements RBRACE . FINALLY LBRACE statements RBRACE

    FINALLY         shift and go to state 140


state 117

    (71) switch -> SWITCH LPARENTHESIS variable RPARENTHESIS . LBRACE cases default_case RBRACE

    LBRACE          shift and go to state 141


state 118

    (19) assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .

    ID              reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    IF              reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    WHILE           reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    FOR             reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    PRINT           reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    CLASS           reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    ENUM            reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    TRY             reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    SWITCH          reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    INT_TYPE        reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    STRING_TYPE     reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    NUM_TYPE        reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    BOOL_TYPE       reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    LIST_TYPE       reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    MAP_TYPE        reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    SET_TYPE        reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    VAR             reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    CONST           reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    FINAL           reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    VOID            reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    INT             reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    DOUBLE          reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    $end            reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    STRING          reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    BOOL            reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    NULL            reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    RBRACE          reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    BREAK           reduce using rule 19 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)


state 119

    (79) parameter -> varType ID .

    RPARENTHESIS    reduce using rule 79 (parameter -> varType ID .)
    COMMA           reduce using rule 79 (parameter -> varType ID .)


state 120

    (64) function -> varType ID LPARENTHESIS parameters RPARENTHESIS . LBRACE statements RBRACE
    (65) function -> varType ID LPARENTHESIS parameters RPARENTHESIS . ARROW expression SEMICOLON

    LBRACE          shift and go to state 142
    ARROW           shift and go to state 143


state 121

    (76) parameters -> parameters COMMA . parameter
    (79) parameter -> . varType ID
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID

    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41

    parameter                      shift and go to state 144
    varType                        shift and go to state 90

state 122

    (81) input -> ID ASSIGN_OPERATOR STDIN DOT READ . LPARENTHESIS RPARENTHESIS SEMICOLON

    LPARENTHESIS    shift and go to state 145


state 123

    (57) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE . statements RBRACE
    (58) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE . statements RBRACE ELSE LBRACE statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    RBRACE          reduce using rule 87 (empty -> .)
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    statements                     shift and go to state 146
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 124

    (55) booleanExpression -> booleanExpression AND booleanExpression .
    (55) booleanExpression -> booleanExpression . AND booleanExpression
    (56) booleanExpression -> booleanExpression . OR booleanExpression

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPARENTHESIS    reduce using rule 55 (booleanExpression -> booleanExpression AND booleanExpression .)
    SEMICOLON       reduce using rule 55 (booleanExpression -> booleanExpression AND booleanExpression .)
    AND             shift and go to state 97
    OR              shift and go to state 98

  ! AND             [ reduce using rule 55 (booleanExpression -> booleanExpression AND booleanExpression .) ]
  ! OR              [ reduce using rule 55 (booleanExpression -> booleanExpression AND booleanExpression .) ]


state 125

    (56) booleanExpression -> booleanExpression OR booleanExpression .
    (55) booleanExpression -> booleanExpression . AND booleanExpression
    (56) booleanExpression -> booleanExpression . OR booleanExpression

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPARENTHESIS    reduce using rule 56 (booleanExpression -> booleanExpression OR booleanExpression .)
    SEMICOLON       reduce using rule 56 (booleanExpression -> booleanExpression OR booleanExpression .)
    AND             shift and go to state 97
    OR              shift and go to state 98

  ! AND             [ reduce using rule 56 (booleanExpression -> booleanExpression OR booleanExpression .) ]
  ! OR              [ reduce using rule 56 (booleanExpression -> booleanExpression OR booleanExpression .) ]


state 126

    (49) booleanExpression -> variable EQUALS variable .

    RPARENTHESIS    reduce using rule 49 (booleanExpression -> variable EQUALS variable .)
    AND             reduce using rule 49 (booleanExpression -> variable EQUALS variable .)
    OR              reduce using rule 49 (booleanExpression -> variable EQUALS variable .)
    SEMICOLON       reduce using rule 49 (booleanExpression -> variable EQUALS variable .)


state 127

    (50) booleanExpression -> variable NOT_EQUALS variable .

    RPARENTHESIS    reduce using rule 50 (booleanExpression -> variable NOT_EQUALS variable .)
    AND             reduce using rule 50 (booleanExpression -> variable NOT_EQUALS variable .)
    OR              reduce using rule 50 (booleanExpression -> variable NOT_EQUALS variable .)
    SEMICOLON       reduce using rule 50 (booleanExpression -> variable NOT_EQUALS variable .)


state 128

    (51) booleanExpression -> variable GREATER_THAN variable .

    RPARENTHESIS    reduce using rule 51 (booleanExpression -> variable GREATER_THAN variable .)
    AND             reduce using rule 51 (booleanExpression -> variable GREATER_THAN variable .)
    OR              reduce using rule 51 (booleanExpression -> variable GREATER_THAN variable .)
    SEMICOLON       reduce using rule 51 (booleanExpression -> variable GREATER_THAN variable .)


state 129

    (52) booleanExpression -> variable LESS_THAN variable .

    RPARENTHESIS    reduce using rule 52 (booleanExpression -> variable LESS_THAN variable .)
    AND             reduce using rule 52 (booleanExpression -> variable LESS_THAN variable .)
    OR              reduce using rule 52 (booleanExpression -> variable LESS_THAN variable .)
    SEMICOLON       reduce using rule 52 (booleanExpression -> variable LESS_THAN variable .)


state 130

    (53) booleanExpression -> variable GREATER_THAN_OR_EQUALS variable .

    RPARENTHESIS    reduce using rule 53 (booleanExpression -> variable GREATER_THAN_OR_EQUALS variable .)
    AND             reduce using rule 53 (booleanExpression -> variable GREATER_THAN_OR_EQUALS variable .)
    OR              reduce using rule 53 (booleanExpression -> variable GREATER_THAN_OR_EQUALS variable .)
    SEMICOLON       reduce using rule 53 (booleanExpression -> variable GREATER_THAN_OR_EQUALS variable .)


state 131

    (54) booleanExpression -> variable LESS_THAN_OR_EQUALS variable .

    RPARENTHESIS    reduce using rule 54 (booleanExpression -> variable LESS_THAN_OR_EQUALS variable .)
    AND             reduce using rule 54 (booleanExpression -> variable LESS_THAN_OR_EQUALS variable .)
    OR              reduce using rule 54 (booleanExpression -> variable LESS_THAN_OR_EQUALS variable .)
    SEMICOLON       reduce using rule 54 (booleanExpression -> variable LESS_THAN_OR_EQUALS variable .)


state 132

    (59) while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    RBRACE          reduce using rule 87 (empty -> .)
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    statements                     shift and go to state 147
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 133

    (60) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON . increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON . decrement RPARENTHESIS LBRACE statements RBRACE
    (62) increment -> . ID INCREMENT
    (63) decrement -> . ID DECREMENT

    ID              shift and go to state 150

    increment                      shift and go to state 148
    decrement                      shift and go to state 149

state 134

    (80) print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .

    ID              reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    IF              reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    FOR             reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    PRINT           reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    CLASS           reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    ENUM            reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    TRY             reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    SWITCH          reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    INT_TYPE        reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    STRING_TYPE     reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    NUM_TYPE        reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    BOOL_TYPE       reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    LIST_TYPE       reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    MAP_TYPE        reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    SET_TYPE        reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    VAR             reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    CONST           reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    FINAL           reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    VOID            reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    INT             reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    DOUBLE          reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    $end            reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    RBRACE          reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    BREAK           reduce using rule 80 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)


state 135

    (82) class_def -> CLASS ID LBRACE class_members RBRACE .

    ID              reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    IF              reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    WHILE           reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    FOR             reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    PRINT           reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    CLASS           reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    ENUM            reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    TRY             reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    SWITCH          reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    INT_TYPE        reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    STRING_TYPE     reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    NUM_TYPE        reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    DOUBLE_TYPE     reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    BOOL_TYPE       reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    LIST_TYPE       reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    MAP_TYPE        reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    SET_TYPE        reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    VAR             reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    CONST           reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    FINAL           reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    VOID            reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    INT             reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    DOUBLE          reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    $end            reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    RBRACE          reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    BREAK           reduce using rule 82 (class_def -> CLASS ID LBRACE class_members RBRACE .)


state 136

    (83) class_members -> class_members class_member .

    RBRACE          reduce using rule 83 (class_members -> class_members class_member .)
    INT_TYPE        reduce using rule 83 (class_members -> class_members class_member .)
    STRING_TYPE     reduce using rule 83 (class_members -> class_members class_member .)
    NUM_TYPE        reduce using rule 83 (class_members -> class_members class_member .)
    DOUBLE_TYPE     reduce using rule 83 (class_members -> class_members class_member .)
    BOOL_TYPE       reduce using rule 83 (class_members -> class_members class_member .)
    LIST_TYPE       reduce using rule 83 (class_members -> class_members class_member .)
    MAP_TYPE        reduce using rule 83 (class_members -> class_members class_member .)
    SET_TYPE        reduce using rule 83 (class_members -> class_members class_member .)
    VAR             reduce using rule 83 (class_members -> class_members class_member .)
    CONST           reduce using rule 83 (class_members -> class_members class_member .)
    FINAL           reduce using rule 83 (class_members -> class_members class_member .)
    VOID            reduce using rule 83 (class_members -> class_members class_member .)


state 137

    (85) class_member -> varType ID . SEMICOLON
    (64) function -> varType ID . LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> varType ID . LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON

    SEMICOLON       shift and go to state 151
    LPARENTHESIS    shift and go to state 68


state 138

    (67) enum -> ENUM ID LBRACE enum_values RBRACE .

    ID              reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    IF              reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    WHILE           reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    FOR             reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    PRINT           reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    CLASS           reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    ENUM            reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    TRY             reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    SWITCH          reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    INT_TYPE        reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    STRING_TYPE     reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    NUM_TYPE        reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    DOUBLE_TYPE     reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    BOOL_TYPE       reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    LIST_TYPE       reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    MAP_TYPE        reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    SET_TYPE        reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    VAR             reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    CONST           reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    FINAL           reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    VOID            reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    INT             reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    DOUBLE          reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    $end            reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    RBRACE          reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    BREAK           reduce using rule 67 (enum -> ENUM ID LBRACE enum_values RBRACE .)


state 139

    (68) enum_values -> enum_values COMMA . ID

    ID              shift and go to state 152


state 140

    (70) try -> TRY LBRACE statements RBRACE FINALLY . LBRACE statements RBRACE

    LBRACE          shift and go to state 153


state 141

    (71) switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE . cases default_case RBRACE
    (72) cases -> . cases case
    (73) cases -> . case
    (74) case -> . CASE variable COLON statements BREAK SEMICOLON

    CASE            shift and go to state 156

    cases                          shift and go to state 154
    case                           shift and go to state 155

state 142

    (64) function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    RBRACE          reduce using rule 87 (empty -> .)
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    varType                        shift and go to state 19
    statements                     shift and go to state 157
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 143

    (65) function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW . expression SEMICOLON
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

    expression                     shift and go to state 158
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 144

    (76) parameters -> parameters COMMA parameter .

    RPARENTHESIS    reduce using rule 76 (parameters -> parameters COMMA parameter .)
    COMMA           reduce using rule 76 (parameters -> parameters COMMA parameter .)


state 145

    (81) input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS . RPARENTHESIS SEMICOLON

    RPARENTHESIS    shift and go to state 159


state 146

    (57) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements . RBRACE
    (58) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements . RBRACE ELSE LBRACE statements RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 160
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! RBRACE          [ reduce using rule 87 (empty -> .) ]
  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    statement                      shift and go to state 44
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 147

    (59) while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 161
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! RBRACE          [ reduce using rule 87 (empty -> .) ]
  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    statement                      shift and go to state 44
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 148

    (60) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment . RPARENTHESIS LBRACE statements RBRACE

    RPARENTHESIS    shift and go to state 162


state 149

    (61) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement . RPARENTHESIS LBRACE statements RBRACE

    RPARENTHESIS    shift and go to state 163


state 150

    (62) increment -> ID . INCREMENT
    (63) decrement -> ID . DECREMENT

    INCREMENT       shift and go to state 164
    DECREMENT       shift and go to state 165


state 151

    (85) class_member -> varType ID SEMICOLON .

    RBRACE          reduce using rule 85 (class_member -> varType ID SEMICOLON .)
    INT_TYPE        reduce using rule 85 (class_member -> varType ID SEMICOLON .)
    STRING_TYPE     reduce using rule 85 (class_member -> varType ID SEMICOLON .)
    NUM_TYPE        reduce using rule 85 (class_member -> varType ID SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 85 (class_member -> varType ID SEMICOLON .)
    BOOL_TYPE       reduce using rule 85 (class_member -> varType ID SEMICOLON .)
    LIST_TYPE       reduce using rule 85 (class_member -> varType ID SEMICOLON .)
    MAP_TYPE        reduce using rule 85 (class_member -> varType ID SEMICOLON .)
    SET_TYPE        reduce using rule 85 (class_member -> varType ID SEMICOLON .)
    VAR             reduce using rule 85 (class_member -> varType ID SEMICOLON .)
    CONST           reduce using rule 85 (class_member -> varType ID SEMICOLON .)
    FINAL           reduce using rule 85 (class_member -> varType ID SEMICOLON .)
    VOID            reduce using rule 85 (class_member -> varType ID SEMICOLON .)


state 152

    (68) enum_values -> enum_values COMMA ID .

    RBRACE          reduce using rule 68 (enum_values -> enum_values COMMA ID .)
    COMMA           reduce using rule 68 (enum_values -> enum_values COMMA ID .)


state 153

    (70) try -> TRY LBRACE statements RBRACE FINALLY LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    RBRACE          reduce using rule 87 (empty -> .)
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    statements                     shift and go to state 166
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 154

    (71) switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases . default_case RBRACE
    (72) cases -> cases . case
    (75) default_case -> . DEFAULT COLON statements
    (74) case -> . CASE variable COLON statements BREAK SEMICOLON

    DEFAULT         shift and go to state 169
    CASE            shift and go to state 156

    default_case                   shift and go to state 167
    case                           shift and go to state 168

state 155

    (73) cases -> case .

    DEFAULT         reduce using rule 73 (cases -> case .)
    CASE            reduce using rule 73 (cases -> case .)


state 156

    (74) case -> CASE . variable COLON statements BREAK SEMICOLON
    (33) variable -> . INT
    (34) variable -> . DOUBLE
    (35) variable -> . STRING
    (36) variable -> . BOOL
    (37) variable -> . NULL
    (38) variable -> . ID
    (39) variable -> . expression
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (47) factor -> . INT
    (48) factor -> . DOUBLE

    INT             shift and go to state 72
    DOUBLE          shift and go to state 73
    STRING          shift and go to state 74
    BOOL            shift and go to state 75
    NULL            shift and go to state 76
    ID              shift and go to state 69

    variable                       shift and go to state 170
    expression                     shift and go to state 77
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 157

    (64) function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 171
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! RBRACE          [ reduce using rule 87 (empty -> .) ]
  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    varType                        shift and go to state 19
    statement                      shift and go to state 44
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    factor                         shift and go to state 29

state 158

    (65) function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression . SEMICOLON
    (40) expression -> expression . PLUS term
    (41) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 172
    PLUS            shift and go to state 46
    MINUS           shift and go to state 47


state 159

    (81) input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 173


state 160

    (57) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .
    (58) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE . ELSE LBRACE statements RBRACE

    ID              reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    IF              reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    WHILE           reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    FOR             reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    PRINT           reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    CLASS           reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    ENUM            reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    TRY             reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    SWITCH          reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    STRING_TYPE     reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    NUM_TYPE        reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE_TYPE     reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    LIST_TYPE       reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    MAP_TYPE        reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    SET_TYPE        reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    VAR             reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    CONST           reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    FINAL           reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    VOID            reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    INT             reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    $end            reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    RBRACE          reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    BREAK           reduce using rule 57 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    ELSE            shift and go to state 174


state 161

    (59) while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .

    ID              reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    IF              reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    WHILE           reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    FOR             reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    PRINT           reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    CLASS           reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    ENUM            reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    TRY             reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    SWITCH          reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    STRING_TYPE     reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    NUM_TYPE        reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE_TYPE     reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    LIST_TYPE       reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    MAP_TYPE        reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    SET_TYPE        reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    VAR             reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    CONST           reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    FINAL           reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    VOID            reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    INT             reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    $end            reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    RBRACE          reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    BREAK           reduce using rule 59 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)


state 162

    (60) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS . LBRACE statements RBRACE

    LBRACE          shift and go to state 175


state 163

    (61) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS . LBRACE statements RBRACE

    LBRACE          shift and go to state 176


state 164

    (62) increment -> ID INCREMENT .

    RPARENTHESIS    reduce using rule 62 (increment -> ID INCREMENT .)


state 165

    (63) decrement -> ID DECREMENT .

    RPARENTHESIS    reduce using rule 63 (decrement -> ID DECREMENT .)


state 166

    (70) try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 177
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! RBRACE          [ reduce using rule 87 (empty -> .) ]
  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    statement                      shift and go to state 44
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 167

    (71) switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case . RBRACE

    RBRACE          shift and go to state 178


state 168

    (72) cases -> cases case .

    DEFAULT         reduce using rule 72 (cases -> cases case .)
    CASE            reduce using rule 72 (cases -> cases case .)


state 169

    (75) default_case -> DEFAULT . COLON statements

    COLON           shift and go to state 179


state 170

    (74) case -> CASE variable . COLON statements BREAK SEMICOLON

    COLON           shift and go to state 180


state 171

    (64) function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .

    ID              reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    IF              reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    WHILE           reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    FOR             reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    PRINT           reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    CLASS           reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    ENUM            reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    TRY             reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    SWITCH          reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    STRING_TYPE     reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    NUM_TYPE        reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE_TYPE     reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    LIST_TYPE       reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    MAP_TYPE        reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    SET_TYPE        reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    VAR             reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    CONST           reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    FINAL           reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    VOID            reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    INT             reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    $end            reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    RBRACE          reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    BREAK           reduce using rule 64 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)


state 172

    (65) function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .

    ID              reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    IF              reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    WHILE           reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    FOR             reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    PRINT           reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    CLASS           reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    ENUM            reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    TRY             reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    SWITCH          reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    INT_TYPE        reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    STRING_TYPE     reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    NUM_TYPE        reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    LIST_TYPE       reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    MAP_TYPE        reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    SET_TYPE        reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    VAR             reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    CONST           reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    FINAL           reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    VOID            reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    INT             reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    DOUBLE          reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    $end            reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    RBRACE          reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)
    BREAK           reduce using rule 65 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON .)


state 173

    (81) input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .

    ID              reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    IF              reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    FOR             reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    PRINT           reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    CLASS           reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    ENUM            reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    TRY             reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    SWITCH          reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    INT_TYPE        reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    STRING_TYPE     reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    NUM_TYPE        reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    BOOL_TYPE       reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    LIST_TYPE       reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    MAP_TYPE        reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    SET_TYPE        reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    VAR             reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    CONST           reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    FINAL           reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    VOID            reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    INT             reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    DOUBLE          reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    $end            reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    RBRACE          reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    BREAK           reduce using rule 81 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)


state 174

    (58) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE . LBRACE statements RBRACE

    LBRACE          shift and go to state 181


state 175

    (60) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    RBRACE          reduce using rule 87 (empty -> .)
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    assignation                    shift and go to state 6
    statements                     shift and go to state 182
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 176

    (61) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    RBRACE          reduce using rule 87 (empty -> .)
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    assignation                    shift and go to state 6
    statements                     shift and go to state 183
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 177

    (70) try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .

    ID              reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    IF              reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    WHILE           reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    FOR             reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    PRINT           reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    CLASS           reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    ENUM            reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    TRY             reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    SWITCH          reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    STRING_TYPE     reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    NUM_TYPE        reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    DOUBLE_TYPE     reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    LIST_TYPE       reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    MAP_TYPE        reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    SET_TYPE        reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    VAR             reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    CONST           reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    FINAL           reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    VOID            reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    INT             reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    $end            reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    RBRACE          reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    BREAK           reduce using rule 70 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)


state 178

    (71) switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .

    ID              reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    IF              reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    WHILE           reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    FOR             reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    PRINT           reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    CLASS           reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    ENUM            reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    TRY             reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    SWITCH          reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    INT_TYPE        reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    STRING_TYPE     reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    NUM_TYPE        reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    DOUBLE_TYPE     reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    BOOL_TYPE       reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    LIST_TYPE       reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    MAP_TYPE        reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    SET_TYPE        reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    VAR             reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    CONST           reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    FINAL           reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    VOID            reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    INT             reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    DOUBLE          reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    $end            reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    RBRACE          reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    BREAK           reduce using rule 71 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)


state 179

    (75) default_case -> DEFAULT COLON . statements
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    RBRACE          reduce using rule 87 (empty -> .)
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    statements                     shift and go to state 184
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 180

    (74) case -> CASE variable COLON . statements BREAK SEMICOLON
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    BREAK           reduce using rule 87 (empty -> .)
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    statements                     shift and go to state 185
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 181

    (58) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    RBRACE          reduce using rule 87 (empty -> .)
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    statements                     shift and go to state 186
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 182

    (60) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 187
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! RBRACE          [ reduce using rule 87 (empty -> .) ]
  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    assignation                    shift and go to state 6
    statement                      shift and go to state 44
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 183

    (61) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 188
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! RBRACE          [ reduce using rule 87 (empty -> .) ]
  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    assignation                    shift and go to state 6
    statement                      shift and go to state 44
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 184

    (75) default_case -> DEFAULT COLON statements .
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 75 (default_case -> DEFAULT COLON statements .)
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          reduce using rule 75 (default_case -> DEFAULT COLON statements .)
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]
  ! RBRACE          [ reduce using rule 87 (empty -> .) ]

    statement                      shift and go to state 44
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 185

    (74) case -> CASE variable COLON statements . BREAK SEMICOLON
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    BREAK           shift and go to state 189
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! BREAK           [ reduce using rule 87 (empty -> .) ]
  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    statement                      shift and go to state 44
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 186

    (58) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . function
    (8) statement -> . if
    (9) statement -> . while
    (10) statement -> . for
    (11) statement -> . print
    (12) statement -> . input
    (13) statement -> . class_def
    (14) statement -> . enum
    (15) statement -> . try
    (16) statement -> . switch
    (17) statement -> . empty
    (40) expression -> . expression PLUS term
    (41) expression -> . expression MINUS term
    (42) expression -> . term
    (18) declaration -> . varType ID SEMICOLON
    (19) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (20) assignation -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (64) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (65) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS ARROW expression SEMICOLON
    (57) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (58) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (59) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (61) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE
    (80) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (81) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (82) class_def -> . CLASS ID LBRACE class_members RBRACE
    (67) enum -> . ENUM ID LBRACE enum_values RBRACE
    (70) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (71) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (87) empty -> .
    (43) term -> . term TIMES factor
    (44) term -> . term DIVIDE factor
    (45) term -> . term MODULE factor
    (46) term -> . factor
    (21) varType -> . INT_TYPE
    (22) varType -> . STRING_TYPE
    (23) varType -> . NUM_TYPE
    (24) varType -> . DOUBLE_TYPE
    (25) varType -> . BOOL_TYPE
    (26) varType -> . LIST_TYPE
    (27) varType -> . MAP_TYPE
    (28) varType -> . SET_TYPE
    (29) varType -> . VAR
    (30) varType -> . CONST
    (31) varType -> . FINAL
    (32) varType -> . VOID
    (47) factor -> . INT
    (48) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 190
    ID              shift and go to state 20
    IF              shift and go to state 21
    WHILE           shift and go to state 22
    FOR             shift and go to state 23
    PRINT           shift and go to state 24
    CLASS           shift and go to state 25
    ENUM            shift and go to state 26
    TRY             shift and go to state 27
    SWITCH          shift and go to state 28
    INT_TYPE        shift and go to state 30
    STRING_TYPE     shift and go to state 31
    NUM_TYPE        shift and go to state 32
    DOUBLE_TYPE     shift and go to state 33
    BOOL_TYPE       shift and go to state 34
    LIST_TYPE       shift and go to state 35
    MAP_TYPE        shift and go to state 36
    SET_TYPE        shift and go to state 37
    VAR             shift and go to state 38
    CONST           shift and go to state 39
    FINAL           shift and go to state 40
    VOID            shift and go to state 41
    INT             shift and go to state 42
    DOUBLE          shift and go to state 43

  ! RBRACE          [ reduce using rule 87 (empty -> .) ]
  ! ID              [ reduce using rule 87 (empty -> .) ]
  ! IF              [ reduce using rule 87 (empty -> .) ]
  ! WHILE           [ reduce using rule 87 (empty -> .) ]
  ! FOR             [ reduce using rule 87 (empty -> .) ]
  ! PRINT           [ reduce using rule 87 (empty -> .) ]
  ! CLASS           [ reduce using rule 87 (empty -> .) ]
  ! ENUM            [ reduce using rule 87 (empty -> .) ]
  ! TRY             [ reduce using rule 87 (empty -> .) ]
  ! SWITCH          [ reduce using rule 87 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 87 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 87 (empty -> .) ]
  ! VAR             [ reduce using rule 87 (empty -> .) ]
  ! CONST           [ reduce using rule 87 (empty -> .) ]
  ! FINAL           [ reduce using rule 87 (empty -> .) ]
  ! VOID            [ reduce using rule 87 (empty -> .) ]
  ! INT             [ reduce using rule 87 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 87 (empty -> .) ]

    statement                      shift and go to state 44
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    function                       shift and go to state 7
    if                             shift and go to state 8
    while                          shift and go to state 9
    for                            shift and go to state 10
    print                          shift and go to state 11
    input                          shift and go to state 12
    class_def                      shift and go to state 13
    enum                           shift and go to state 14
    try                            shift and go to state 15
    switch                         shift and go to state 16
    empty                          shift and go to state 17
    term                           shift and go to state 18
    varType                        shift and go to state 19
    factor                         shift and go to state 29

state 187

    (60) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .

    ID              reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    IF              reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    WHILE           reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    FOR             reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    PRINT           reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    CLASS           reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    ENUM            reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    TRY             reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    SWITCH          reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    STRING_TYPE     reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    NUM_TYPE        reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE_TYPE     reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    LIST_TYPE       reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    MAP_TYPE        reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    SET_TYPE        reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    VAR             reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    CONST           reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    FINAL           reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    VOID            reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    INT             reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    $end            reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    RBRACE          reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    BREAK           reduce using rule 60 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)


state 188

    (61) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .

    ID              reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    IF              reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    WHILE           reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    FOR             reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    PRINT           reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    CLASS           reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    ENUM            reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    TRY             reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    SWITCH          reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    STRING_TYPE     reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    NUM_TYPE        reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE_TYPE     reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    LIST_TYPE       reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    MAP_TYPE        reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    SET_TYPE        reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    VAR             reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    CONST           reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    FINAL           reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    VOID            reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    INT             reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    $end            reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    RBRACE          reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)
    BREAK           reduce using rule 61 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON decrement RPARENTHESIS LBRACE statements RBRACE .)


state 189

    (74) case -> CASE variable COLON statements BREAK . SEMICOLON

    SEMICOLON       shift and go to state 191


state 190

    (58) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .

    ID              reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    IF              reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    WHILE           reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    FOR             reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    PRINT           reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    CLASS           reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    ENUM            reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    TRY             reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    SWITCH          reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    STRING_TYPE     reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    NUM_TYPE        reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    DOUBLE_TYPE     reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    LIST_TYPE       reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    MAP_TYPE        reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    SET_TYPE        reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    VAR             reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    CONST           reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    FINAL           reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    VOID            reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    INT             reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    $end            reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    RBRACE          reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    BREAK           reduce using rule 58 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)


state 191

    (74) case -> CASE variable COLON statements BREAK SEMICOLON .

    DEFAULT         reduce using rule 74 (case -> CASE variable COLON statements BREAK SEMICOLON .)
    CASE            reduce using rule 74 (case -> CASE variable COLON statements BREAK SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 0 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 0 resolved as shift
WARNING: shift/reduce conflict for TRY in state 0 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for CONST in state 0 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 0 resolved as shift
WARNING: shift/reduce conflict for VOID in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 2 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 2 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 2 resolved as shift
WARNING: shift/reduce conflict for TRY in state 2 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 2 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for CONST in state 2 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 2 resolved as shift
WARNING: shift/reduce conflict for VOID in state 2 resolved as shift
WARNING: shift/reduce conflict for INT in state 2 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 2 resolved as shift
WARNING: shift/reduce conflict for ID in state 59 resolved as shift
WARNING: shift/reduce conflict for IF in state 59 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 59 resolved as shift
WARNING: shift/reduce conflict for FOR in state 59 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 59 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 59 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 59 resolved as shift
WARNING: shift/reduce conflict for TRY in state 59 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 59 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 59 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 59 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 59 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 59 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 59 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 59 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 59 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 59 resolved as shift
WARNING: shift/reduce conflict for VAR in state 59 resolved as shift
WARNING: shift/reduce conflict for CONST in state 59 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 59 resolved as shift
WARNING: shift/reduce conflict for VOID in state 59 resolved as shift
WARNING: shift/reduce conflict for INT in state 59 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 59 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 87 resolved as shift
WARNING: shift/reduce conflict for ID in state 87 resolved as shift
WARNING: shift/reduce conflict for IF in state 87 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 87 resolved as shift
WARNING: shift/reduce conflict for FOR in state 87 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 87 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 87 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 87 resolved as shift
WARNING: shift/reduce conflict for TRY in state 87 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 87 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 87 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 87 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 87 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 87 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 87 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 87 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 87 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 87 resolved as shift
WARNING: shift/reduce conflict for VAR in state 87 resolved as shift
WARNING: shift/reduce conflict for CONST in state 87 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 87 resolved as shift
WARNING: shift/reduce conflict for VOID in state 87 resolved as shift
WARNING: shift/reduce conflict for INT in state 87 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 87 resolved as shift
WARNING: shift/reduce conflict for ID in state 123 resolved as shift
WARNING: shift/reduce conflict for IF in state 123 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 123 resolved as shift
WARNING: shift/reduce conflict for FOR in state 123 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 123 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 123 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 123 resolved as shift
WARNING: shift/reduce conflict for TRY in state 123 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 123 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for VAR in state 123 resolved as shift
WARNING: shift/reduce conflict for CONST in state 123 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 123 resolved as shift
WARNING: shift/reduce conflict for VOID in state 123 resolved as shift
WARNING: shift/reduce conflict for INT in state 123 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 123 resolved as shift
WARNING: shift/reduce conflict for AND in state 124 resolved as shift
WARNING: shift/reduce conflict for OR in state 124 resolved as shift
WARNING: shift/reduce conflict for AND in state 125 resolved as shift
WARNING: shift/reduce conflict for OR in state 125 resolved as shift
WARNING: shift/reduce conflict for ID in state 132 resolved as shift
WARNING: shift/reduce conflict for IF in state 132 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 132 resolved as shift
WARNING: shift/reduce conflict for FOR in state 132 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 132 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 132 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 132 resolved as shift
WARNING: shift/reduce conflict for TRY in state 132 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 132 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 132 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 132 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 132 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 132 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 132 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 132 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 132 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 132 resolved as shift
WARNING: shift/reduce conflict for VAR in state 132 resolved as shift
WARNING: shift/reduce conflict for CONST in state 132 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 132 resolved as shift
WARNING: shift/reduce conflict for VOID in state 132 resolved as shift
WARNING: shift/reduce conflict for INT in state 132 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 132 resolved as shift
WARNING: shift/reduce conflict for ID in state 142 resolved as shift
WARNING: shift/reduce conflict for IF in state 142 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 142 resolved as shift
WARNING: shift/reduce conflict for FOR in state 142 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 142 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 142 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 142 resolved as shift
WARNING: shift/reduce conflict for TRY in state 142 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 142 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 142 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 142 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 142 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 142 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 142 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 142 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 142 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 142 resolved as shift
WARNING: shift/reduce conflict for VAR in state 142 resolved as shift
WARNING: shift/reduce conflict for CONST in state 142 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 142 resolved as shift
WARNING: shift/reduce conflict for VOID in state 142 resolved as shift
WARNING: shift/reduce conflict for INT in state 142 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 142 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 146 resolved as shift
WARNING: shift/reduce conflict for ID in state 146 resolved as shift
WARNING: shift/reduce conflict for IF in state 146 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 146 resolved as shift
WARNING: shift/reduce conflict for FOR in state 146 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 146 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 146 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 146 resolved as shift
WARNING: shift/reduce conflict for TRY in state 146 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 146 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 146 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 146 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 146 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 146 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 146 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 146 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 146 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 146 resolved as shift
WARNING: shift/reduce conflict for VAR in state 146 resolved as shift
WARNING: shift/reduce conflict for CONST in state 146 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 146 resolved as shift
WARNING: shift/reduce conflict for VOID in state 146 resolved as shift
WARNING: shift/reduce conflict for INT in state 146 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 146 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 147 resolved as shift
WARNING: shift/reduce conflict for ID in state 147 resolved as shift
WARNING: shift/reduce conflict for IF in state 147 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 147 resolved as shift
WARNING: shift/reduce conflict for FOR in state 147 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 147 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 147 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 147 resolved as shift
WARNING: shift/reduce conflict for TRY in state 147 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 147 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 147 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 147 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 147 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 147 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 147 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 147 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 147 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 147 resolved as shift
WARNING: shift/reduce conflict for VAR in state 147 resolved as shift
WARNING: shift/reduce conflict for CONST in state 147 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 147 resolved as shift
WARNING: shift/reduce conflict for VOID in state 147 resolved as shift
WARNING: shift/reduce conflict for INT in state 147 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 147 resolved as shift
WARNING: shift/reduce conflict for ID in state 153 resolved as shift
WARNING: shift/reduce conflict for IF in state 153 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 153 resolved as shift
WARNING: shift/reduce conflict for FOR in state 153 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 153 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 153 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 153 resolved as shift
WARNING: shift/reduce conflict for TRY in state 153 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 153 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for VAR in state 153 resolved as shift
WARNING: shift/reduce conflict for CONST in state 153 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 153 resolved as shift
WARNING: shift/reduce conflict for VOID in state 153 resolved as shift
WARNING: shift/reduce conflict for INT in state 153 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 153 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 157 resolved as shift
WARNING: shift/reduce conflict for ID in state 157 resolved as shift
WARNING: shift/reduce conflict for IF in state 157 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 157 resolved as shift
WARNING: shift/reduce conflict for FOR in state 157 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 157 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 157 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 157 resolved as shift
WARNING: shift/reduce conflict for TRY in state 157 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 157 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 157 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 157 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 157 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 157 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 157 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 157 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 157 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 157 resolved as shift
WARNING: shift/reduce conflict for VAR in state 157 resolved as shift
WARNING: shift/reduce conflict for CONST in state 157 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 157 resolved as shift
WARNING: shift/reduce conflict for VOID in state 157 resolved as shift
WARNING: shift/reduce conflict for INT in state 157 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 157 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 166 resolved as shift
WARNING: shift/reduce conflict for ID in state 166 resolved as shift
WARNING: shift/reduce conflict for IF in state 166 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 166 resolved as shift
WARNING: shift/reduce conflict for FOR in state 166 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 166 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 166 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 166 resolved as shift
WARNING: shift/reduce conflict for TRY in state 166 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 166 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 166 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 166 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 166 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 166 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 166 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 166 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 166 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 166 resolved as shift
WARNING: shift/reduce conflict for VAR in state 166 resolved as shift
WARNING: shift/reduce conflict for CONST in state 166 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 166 resolved as shift
WARNING: shift/reduce conflict for VOID in state 166 resolved as shift
WARNING: shift/reduce conflict for INT in state 166 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 166 resolved as shift
WARNING: shift/reduce conflict for ID in state 175 resolved as shift
WARNING: shift/reduce conflict for IF in state 175 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 175 resolved as shift
WARNING: shift/reduce conflict for FOR in state 175 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 175 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 175 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 175 resolved as shift
WARNING: shift/reduce conflict for TRY in state 175 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 175 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for VAR in state 175 resolved as shift
WARNING: shift/reduce conflict for CONST in state 175 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 175 resolved as shift
WARNING: shift/reduce conflict for VOID in state 175 resolved as shift
WARNING: shift/reduce conflict for INT in state 175 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 175 resolved as shift
WARNING: shift/reduce conflict for ID in state 176 resolved as shift
WARNING: shift/reduce conflict for IF in state 176 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 176 resolved as shift
WARNING: shift/reduce conflict for FOR in state 176 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 176 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 176 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 176 resolved as shift
WARNING: shift/reduce conflict for TRY in state 176 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 176 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for VAR in state 176 resolved as shift
WARNING: shift/reduce conflict for CONST in state 176 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 176 resolved as shift
WARNING: shift/reduce conflict for VOID in state 176 resolved as shift
WARNING: shift/reduce conflict for INT in state 176 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 176 resolved as shift
WARNING: shift/reduce conflict for ID in state 179 resolved as shift
WARNING: shift/reduce conflict for IF in state 179 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 179 resolved as shift
WARNING: shift/reduce conflict for FOR in state 179 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 179 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 179 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 179 resolved as shift
WARNING: shift/reduce conflict for TRY in state 179 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 179 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 179 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 179 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 179 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 179 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 179 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 179 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 179 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 179 resolved as shift
WARNING: shift/reduce conflict for VAR in state 179 resolved as shift
WARNING: shift/reduce conflict for CONST in state 179 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 179 resolved as shift
WARNING: shift/reduce conflict for VOID in state 179 resolved as shift
WARNING: shift/reduce conflict for INT in state 179 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 179 resolved as shift
WARNING: shift/reduce conflict for ID in state 180 resolved as shift
WARNING: shift/reduce conflict for IF in state 180 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 180 resolved as shift
WARNING: shift/reduce conflict for FOR in state 180 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 180 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 180 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 180 resolved as shift
WARNING: shift/reduce conflict for TRY in state 180 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 180 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 180 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 180 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 180 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 180 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 180 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 180 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 180 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 180 resolved as shift
WARNING: shift/reduce conflict for VAR in state 180 resolved as shift
WARNING: shift/reduce conflict for CONST in state 180 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 180 resolved as shift
WARNING: shift/reduce conflict for VOID in state 180 resolved as shift
WARNING: shift/reduce conflict for INT in state 180 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 180 resolved as shift
WARNING: shift/reduce conflict for ID in state 181 resolved as shift
WARNING: shift/reduce conflict for IF in state 181 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 181 resolved as shift
WARNING: shift/reduce conflict for FOR in state 181 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 181 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 181 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 181 resolved as shift
WARNING: shift/reduce conflict for TRY in state 181 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 181 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 181 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 181 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 181 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 181 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 181 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 181 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 181 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 181 resolved as shift
WARNING: shift/reduce conflict for VAR in state 181 resolved as shift
WARNING: shift/reduce conflict for CONST in state 181 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 181 resolved as shift
WARNING: shift/reduce conflict for VOID in state 181 resolved as shift
WARNING: shift/reduce conflict for INT in state 181 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 181 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 182 resolved as shift
WARNING: shift/reduce conflict for ID in state 182 resolved as shift
WARNING: shift/reduce conflict for IF in state 182 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 182 resolved as shift
WARNING: shift/reduce conflict for FOR in state 182 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 182 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 182 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 182 resolved as shift
WARNING: shift/reduce conflict for TRY in state 182 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 182 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 182 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 182 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 182 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 182 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 182 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 182 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 182 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 182 resolved as shift
WARNING: shift/reduce conflict for VAR in state 182 resolved as shift
WARNING: shift/reduce conflict for CONST in state 182 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 182 resolved as shift
WARNING: shift/reduce conflict for VOID in state 182 resolved as shift
WARNING: shift/reduce conflict for INT in state 182 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 182 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 183 resolved as shift
WARNING: shift/reduce conflict for ID in state 183 resolved as shift
WARNING: shift/reduce conflict for IF in state 183 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 183 resolved as shift
WARNING: shift/reduce conflict for FOR in state 183 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 183 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 183 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 183 resolved as shift
WARNING: shift/reduce conflict for TRY in state 183 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 183 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 183 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 183 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 183 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 183 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 183 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 183 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 183 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 183 resolved as shift
WARNING: shift/reduce conflict for VAR in state 183 resolved as shift
WARNING: shift/reduce conflict for CONST in state 183 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 183 resolved as shift
WARNING: shift/reduce conflict for VOID in state 183 resolved as shift
WARNING: shift/reduce conflict for INT in state 183 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 183 resolved as shift
WARNING: shift/reduce conflict for ID in state 184 resolved as shift
WARNING: shift/reduce conflict for IF in state 184 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 184 resolved as shift
WARNING: shift/reduce conflict for FOR in state 184 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 184 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 184 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 184 resolved as shift
WARNING: shift/reduce conflict for TRY in state 184 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 184 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 184 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 184 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 184 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 184 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 184 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 184 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 184 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 184 resolved as shift
WARNING: shift/reduce conflict for VAR in state 184 resolved as shift
WARNING: shift/reduce conflict for CONST in state 184 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 184 resolved as shift
WARNING: shift/reduce conflict for VOID in state 184 resolved as shift
WARNING: shift/reduce conflict for INT in state 184 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 184 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 185 resolved as shift
WARNING: shift/reduce conflict for ID in state 185 resolved as shift
WARNING: shift/reduce conflict for IF in state 185 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 185 resolved as shift
WARNING: shift/reduce conflict for FOR in state 185 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 185 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 185 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 185 resolved as shift
WARNING: shift/reduce conflict for TRY in state 185 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 185 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 185 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 185 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 185 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 185 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 185 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 185 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 185 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 185 resolved as shift
WARNING: shift/reduce conflict for VAR in state 185 resolved as shift
WARNING: shift/reduce conflict for CONST in state 185 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 185 resolved as shift
WARNING: shift/reduce conflict for VOID in state 185 resolved as shift
WARNING: shift/reduce conflict for INT in state 185 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 185 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 186 resolved as shift
WARNING: shift/reduce conflict for ID in state 186 resolved as shift
WARNING: shift/reduce conflict for IF in state 186 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 186 resolved as shift
WARNING: shift/reduce conflict for FOR in state 186 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 186 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 186 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 186 resolved as shift
WARNING: shift/reduce conflict for TRY in state 186 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 186 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 186 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 186 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 186 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 186 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 186 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 186 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 186 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 186 resolved as shift
WARNING: shift/reduce conflict for VAR in state 186 resolved as shift
WARNING: shift/reduce conflict for CONST in state 186 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 186 resolved as shift
WARNING: shift/reduce conflict for VOID in state 186 resolved as shift
WARNING: shift/reduce conflict for INT in state 186 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 186 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (program -> statements)
WARNING: rejected rule (empty -> <empty>) in state 2
WARNING: reduce/reduce conflict in state 72 resolved using rule (variable -> INT)
WARNING: rejected rule (factor -> INT) in state 72
WARNING: reduce/reduce conflict in state 73 resolved using rule (variable -> DOUBLE)
WARNING: rejected rule (factor -> DOUBLE) in state 73
WARNING: reduce/reduce conflict in state 184 resolved using rule (default_case -> DEFAULT COLON statements)
WARNING: rejected rule (empty -> <empty>) in state 184
