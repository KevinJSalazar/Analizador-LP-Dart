Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    AND
    ARROW
    CONTINUE
    DECREMENT
    EXPORT
    FALSE
    IMPORT
    LATE
    LBRACKET
    NOT
    NULL_TYPE
    OR
    RBRACKET
    RETURN
    STATIC
    TRUE
    TYPEDEF

Grammar

Rule 0     S' -> program
Rule 1     program -> statements
Rule 2     statements -> statements statement
Rule 3     statements -> statement
Rule 4     statement -> expression SEMICOLON
Rule 5     statement -> declaration
Rule 6     statement -> assignation
Rule 7     statement -> assignation_no_type
Rule 8     statement -> function
Rule 9     statement -> if
Rule 10    statement -> while
Rule 11    statement -> for
Rule 12    statement -> print
Rule 13    statement -> input
Rule 14    statement -> class_def
Rule 15    statement -> enum
Rule 16    statement -> try
Rule 17    statement -> switch
Rule 18    statement -> list
Rule 19    statement -> set
Rule 20    statement -> map
Rule 21    statement -> empty
Rule 22    declaration -> varType ID SEMICOLON
Rule 23    assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON
Rule 24    assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON
Rule 25    expression -> expression PLUS term
Rule 26    expression -> expression MINUS term
Rule 27    expression -> term
Rule 28    term -> term TIMES factor
Rule 29    term -> term DIVIDE factor
Rule 30    term -> term MODULE factor
Rule 31    term -> factor
Rule 32    factor -> INT
Rule 33    factor -> DOUBLE
Rule 34    variable -> INT
Rule 35    variable -> DOUBLE
Rule 36    variable -> STRING
Rule 37    variable -> BOOL
Rule 38    variable -> NULL
Rule 39    variable -> ID
Rule 40    variable -> expression
Rule 41    varType -> INT_TYPE
Rule 42    varType -> STRING_TYPE
Rule 43    varType -> NUM_TYPE
Rule 44    varType -> DOUBLE_TYPE
Rule 45    varType -> BOOL_TYPE
Rule 46    varType -> LIST_TYPE
Rule 47    varType -> MAP_TYPE
Rule 48    varType -> SET_TYPE
Rule 49    varType -> VAR
Rule 50    varType -> CONST
Rule 51    varType -> FINAL
Rule 52    varType -> VOID
Rule 53    booleanExpression -> variable EQUALS variable
Rule 54    booleanExpression -> variable NOT_EQUALS variable
Rule 55    booleanExpression -> variable GREATER_THAN variable
Rule 56    booleanExpression -> variable LESS_THAN variable
Rule 57    booleanExpression -> variable GREATER_THAN_OR_EQUALS variable
Rule 58    booleanExpression -> variable LESS_THAN_OR_EQUALS variable
Rule 59    if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
Rule 60    if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
Rule 61    while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
Rule 62    for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
Rule 63    increment -> ID INCREMENT
Rule 64    print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
Rule 65    input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
Rule 66    class_def -> CLASS ID LBRACE class_members RBRACE
Rule 67    class_members -> class_members class_member
Rule 68    class_members -> class_member
Rule 69    class_member -> varType ID SEMICOLON
Rule 70    class_member -> function
Rule 71    function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
Rule 72    enum -> ENUM ID LBRACE enum_values RBRACE
Rule 73    enum_values -> enum_values COMMA ID
Rule 74    enum_values -> ID
Rule 75    try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
Rule 76    switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
Rule 77    cases -> cases case
Rule 78    cases -> case
Rule 79    case -> CASE variable COLON statements BREAK SEMICOLON
Rule 80    default_case -> DEFAULT COLON statements
Rule 81    parameters -> parameters COMMA parameter
Rule 82    parameters -> parameter
Rule 83    parameters -> empty
Rule 84    parameter -> varType ID
Rule 85    list -> empty
Rule 86    set -> empty
Rule 87    map -> empty
Rule 88    empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
AND                  : 
ARROW                : 
ASSIGN_OPERATOR      : 23 24 65
BOOL                 : 37
BOOL_TYPE            : 45
BREAK                : 79
CASE                 : 79
CLASS                : 66
COLON                : 79 80
COMMA                : 73 81
CONST                : 50
CONTINUE             : 
DECREMENT            : 
DEFAULT              : 80
DIVIDE               : 29
DOT                  : 65
DOUBLE               : 33 35
DOUBLE_TYPE          : 44
ELSE                 : 60
ENUM                 : 72
EQUALS               : 53
EXPORT               : 
FALSE                : 
FINAL                : 51
FINALLY              : 75
FOR                  : 62
GREATER_THAN         : 55
GREATER_THAN_OR_EQUALS : 57
ID                   : 22 23 24 39 63 65 66 69 71 72 73 74 84
IF                   : 59 60
IMPORT               : 
INCREMENT            : 63
INT                  : 32 34
INT_TYPE             : 41
LATE                 : 
LBRACE               : 59 60 60 61 62 66 71 72 75 75 76
LBRACKET             : 
LESS_THAN            : 56
LESS_THAN_OR_EQUALS  : 58
LIST_TYPE            : 46
LPARENTHESIS         : 59 60 61 62 64 65 71 76
MAP_TYPE             : 47
MINUS                : 26
MODULE               : 30
NOT                  : 
NOT_EQUALS           : 54
NULL                 : 38
NULL_TYPE            : 
NUM_TYPE             : 43
OR                   : 
PLUS                 : 25
PRINT                : 64
RBRACE               : 59 60 60 61 62 66 71 72 75 75 76
RBRACKET             : 
READ                 : 65
RETURN               : 
RPARENTHESIS         : 59 60 61 62 64 65 71 76
SEMICOLON            : 4 22 23 24 62 64 65 69 79
SET_TYPE             : 48
STATIC               : 
STDIN                : 65
STRING               : 36
STRING_TYPE          : 42
SWITCH               : 76
TIMES                : 28
TRUE                 : 
TRY                  : 75
TYPEDEF              : 
VAR                  : 49
VOID                 : 52
WHILE                : 61
error                : 

Nonterminals, with rules where they appear

assignation          : 6 62
assignation_no_type  : 7
booleanExpression    : 59 60 61 62
case                 : 77 78
cases                : 76 77
class_def            : 14
class_member         : 67 68
class_members        : 66 67
declaration          : 5
default_case         : 76
empty                : 21 83 85 86 87
enum                 : 15
enum_values          : 72 73
expression           : 4 25 26 40 64
factor               : 28 29 30 31
for                  : 11
function             : 8 70
if                   : 9
increment            : 62
input                : 13
list                 : 18
map                  : 20
parameter            : 81 82
parameters           : 71 81
print                : 12
program              : 0
set                  : 19
statement            : 2 3
statements           : 1 2 59 60 60 61 62 71 75 75 79 80
switch               : 17
term                 : 25 26 27 28 29 30
try                  : 16
varType              : 22 23 69 71 84
variable             : 23 24 53 53 54 54 55 55 56 56 57 57 58 58 76 79
while                : 10

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statements
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    $end            reduce using rule 88 (empty -> .)
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    program                        shift and go to state 1
    statements                     shift and go to state 2
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 1

    (0) S' -> program .



state 2

    (1) program -> statements .
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 1 (program -> statements .)
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    $end            reduce using rule 1 (program -> statements .)
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]
  ! $end            [ reduce using rule 88 (empty -> .) ]

    statement                      shift and go to state 48
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 3

    (3) statements -> statement .

    ID              reduce using rule 3 (statements -> statement .)
    IF              reduce using rule 3 (statements -> statement .)
    WHILE           reduce using rule 3 (statements -> statement .)
    FOR             reduce using rule 3 (statements -> statement .)
    PRINT           reduce using rule 3 (statements -> statement .)
    CLASS           reduce using rule 3 (statements -> statement .)
    ENUM            reduce using rule 3 (statements -> statement .)
    TRY             reduce using rule 3 (statements -> statement .)
    SWITCH          reduce using rule 3 (statements -> statement .)
    INT_TYPE        reduce using rule 3 (statements -> statement .)
    STRING_TYPE     reduce using rule 3 (statements -> statement .)
    NUM_TYPE        reduce using rule 3 (statements -> statement .)
    DOUBLE_TYPE     reduce using rule 3 (statements -> statement .)
    BOOL_TYPE       reduce using rule 3 (statements -> statement .)
    LIST_TYPE       reduce using rule 3 (statements -> statement .)
    MAP_TYPE        reduce using rule 3 (statements -> statement .)
    SET_TYPE        reduce using rule 3 (statements -> statement .)
    VAR             reduce using rule 3 (statements -> statement .)
    CONST           reduce using rule 3 (statements -> statement .)
    FINAL           reduce using rule 3 (statements -> statement .)
    VOID            reduce using rule 3 (statements -> statement .)
    INT             reduce using rule 3 (statements -> statement .)
    DOUBLE          reduce using rule 3 (statements -> statement .)
    $end            reduce using rule 3 (statements -> statement .)
    RBRACE          reduce using rule 3 (statements -> statement .)
    BREAK           reduce using rule 3 (statements -> statement .)


state 4

    (4) statement -> expression . SEMICOLON
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    SEMICOLON       shift and go to state 49
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51


state 5

    (5) statement -> declaration .

    ID              reduce using rule 5 (statement -> declaration .)
    IF              reduce using rule 5 (statement -> declaration .)
    WHILE           reduce using rule 5 (statement -> declaration .)
    FOR             reduce using rule 5 (statement -> declaration .)
    PRINT           reduce using rule 5 (statement -> declaration .)
    CLASS           reduce using rule 5 (statement -> declaration .)
    ENUM            reduce using rule 5 (statement -> declaration .)
    TRY             reduce using rule 5 (statement -> declaration .)
    SWITCH          reduce using rule 5 (statement -> declaration .)
    INT_TYPE        reduce using rule 5 (statement -> declaration .)
    STRING_TYPE     reduce using rule 5 (statement -> declaration .)
    NUM_TYPE        reduce using rule 5 (statement -> declaration .)
    DOUBLE_TYPE     reduce using rule 5 (statement -> declaration .)
    BOOL_TYPE       reduce using rule 5 (statement -> declaration .)
    LIST_TYPE       reduce using rule 5 (statement -> declaration .)
    MAP_TYPE        reduce using rule 5 (statement -> declaration .)
    SET_TYPE        reduce using rule 5 (statement -> declaration .)
    VAR             reduce using rule 5 (statement -> declaration .)
    CONST           reduce using rule 5 (statement -> declaration .)
    FINAL           reduce using rule 5 (statement -> declaration .)
    VOID            reduce using rule 5 (statement -> declaration .)
    INT             reduce using rule 5 (statement -> declaration .)
    DOUBLE          reduce using rule 5 (statement -> declaration .)
    $end            reduce using rule 5 (statement -> declaration .)
    RBRACE          reduce using rule 5 (statement -> declaration .)
    BREAK           reduce using rule 5 (statement -> declaration .)


state 6

    (6) statement -> assignation .

    ID              reduce using rule 6 (statement -> assignation .)
    IF              reduce using rule 6 (statement -> assignation .)
    WHILE           reduce using rule 6 (statement -> assignation .)
    FOR             reduce using rule 6 (statement -> assignation .)
    PRINT           reduce using rule 6 (statement -> assignation .)
    CLASS           reduce using rule 6 (statement -> assignation .)
    ENUM            reduce using rule 6 (statement -> assignation .)
    TRY             reduce using rule 6 (statement -> assignation .)
    SWITCH          reduce using rule 6 (statement -> assignation .)
    INT_TYPE        reduce using rule 6 (statement -> assignation .)
    STRING_TYPE     reduce using rule 6 (statement -> assignation .)
    NUM_TYPE        reduce using rule 6 (statement -> assignation .)
    DOUBLE_TYPE     reduce using rule 6 (statement -> assignation .)
    BOOL_TYPE       reduce using rule 6 (statement -> assignation .)
    LIST_TYPE       reduce using rule 6 (statement -> assignation .)
    MAP_TYPE        reduce using rule 6 (statement -> assignation .)
    SET_TYPE        reduce using rule 6 (statement -> assignation .)
    VAR             reduce using rule 6 (statement -> assignation .)
    CONST           reduce using rule 6 (statement -> assignation .)
    FINAL           reduce using rule 6 (statement -> assignation .)
    VOID            reduce using rule 6 (statement -> assignation .)
    INT             reduce using rule 6 (statement -> assignation .)
    DOUBLE          reduce using rule 6 (statement -> assignation .)
    $end            reduce using rule 6 (statement -> assignation .)
    RBRACE          reduce using rule 6 (statement -> assignation .)
    BREAK           reduce using rule 6 (statement -> assignation .)


state 7

    (7) statement -> assignation_no_type .

    ID              reduce using rule 7 (statement -> assignation_no_type .)
    IF              reduce using rule 7 (statement -> assignation_no_type .)
    WHILE           reduce using rule 7 (statement -> assignation_no_type .)
    FOR             reduce using rule 7 (statement -> assignation_no_type .)
    PRINT           reduce using rule 7 (statement -> assignation_no_type .)
    CLASS           reduce using rule 7 (statement -> assignation_no_type .)
    ENUM            reduce using rule 7 (statement -> assignation_no_type .)
    TRY             reduce using rule 7 (statement -> assignation_no_type .)
    SWITCH          reduce using rule 7 (statement -> assignation_no_type .)
    INT_TYPE        reduce using rule 7 (statement -> assignation_no_type .)
    STRING_TYPE     reduce using rule 7 (statement -> assignation_no_type .)
    NUM_TYPE        reduce using rule 7 (statement -> assignation_no_type .)
    DOUBLE_TYPE     reduce using rule 7 (statement -> assignation_no_type .)
    BOOL_TYPE       reduce using rule 7 (statement -> assignation_no_type .)
    LIST_TYPE       reduce using rule 7 (statement -> assignation_no_type .)
    MAP_TYPE        reduce using rule 7 (statement -> assignation_no_type .)
    SET_TYPE        reduce using rule 7 (statement -> assignation_no_type .)
    VAR             reduce using rule 7 (statement -> assignation_no_type .)
    CONST           reduce using rule 7 (statement -> assignation_no_type .)
    FINAL           reduce using rule 7 (statement -> assignation_no_type .)
    VOID            reduce using rule 7 (statement -> assignation_no_type .)
    INT             reduce using rule 7 (statement -> assignation_no_type .)
    DOUBLE          reduce using rule 7 (statement -> assignation_no_type .)
    $end            reduce using rule 7 (statement -> assignation_no_type .)
    RBRACE          reduce using rule 7 (statement -> assignation_no_type .)
    BREAK           reduce using rule 7 (statement -> assignation_no_type .)


state 8

    (8) statement -> function .

    ID              reduce using rule 8 (statement -> function .)
    IF              reduce using rule 8 (statement -> function .)
    WHILE           reduce using rule 8 (statement -> function .)
    FOR             reduce using rule 8 (statement -> function .)
    PRINT           reduce using rule 8 (statement -> function .)
    CLASS           reduce using rule 8 (statement -> function .)
    ENUM            reduce using rule 8 (statement -> function .)
    TRY             reduce using rule 8 (statement -> function .)
    SWITCH          reduce using rule 8 (statement -> function .)
    INT_TYPE        reduce using rule 8 (statement -> function .)
    STRING_TYPE     reduce using rule 8 (statement -> function .)
    NUM_TYPE        reduce using rule 8 (statement -> function .)
    DOUBLE_TYPE     reduce using rule 8 (statement -> function .)
    BOOL_TYPE       reduce using rule 8 (statement -> function .)
    LIST_TYPE       reduce using rule 8 (statement -> function .)
    MAP_TYPE        reduce using rule 8 (statement -> function .)
    SET_TYPE        reduce using rule 8 (statement -> function .)
    VAR             reduce using rule 8 (statement -> function .)
    CONST           reduce using rule 8 (statement -> function .)
    FINAL           reduce using rule 8 (statement -> function .)
    VOID            reduce using rule 8 (statement -> function .)
    INT             reduce using rule 8 (statement -> function .)
    DOUBLE          reduce using rule 8 (statement -> function .)
    $end            reduce using rule 8 (statement -> function .)
    RBRACE          reduce using rule 8 (statement -> function .)
    BREAK           reduce using rule 8 (statement -> function .)


state 9

    (9) statement -> if .

    ID              reduce using rule 9 (statement -> if .)
    IF              reduce using rule 9 (statement -> if .)
    WHILE           reduce using rule 9 (statement -> if .)
    FOR             reduce using rule 9 (statement -> if .)
    PRINT           reduce using rule 9 (statement -> if .)
    CLASS           reduce using rule 9 (statement -> if .)
    ENUM            reduce using rule 9 (statement -> if .)
    TRY             reduce using rule 9 (statement -> if .)
    SWITCH          reduce using rule 9 (statement -> if .)
    INT_TYPE        reduce using rule 9 (statement -> if .)
    STRING_TYPE     reduce using rule 9 (statement -> if .)
    NUM_TYPE        reduce using rule 9 (statement -> if .)
    DOUBLE_TYPE     reduce using rule 9 (statement -> if .)
    BOOL_TYPE       reduce using rule 9 (statement -> if .)
    LIST_TYPE       reduce using rule 9 (statement -> if .)
    MAP_TYPE        reduce using rule 9 (statement -> if .)
    SET_TYPE        reduce using rule 9 (statement -> if .)
    VAR             reduce using rule 9 (statement -> if .)
    CONST           reduce using rule 9 (statement -> if .)
    FINAL           reduce using rule 9 (statement -> if .)
    VOID            reduce using rule 9 (statement -> if .)
    INT             reduce using rule 9 (statement -> if .)
    DOUBLE          reduce using rule 9 (statement -> if .)
    $end            reduce using rule 9 (statement -> if .)
    RBRACE          reduce using rule 9 (statement -> if .)
    BREAK           reduce using rule 9 (statement -> if .)


state 10

    (10) statement -> while .

    ID              reduce using rule 10 (statement -> while .)
    IF              reduce using rule 10 (statement -> while .)
    WHILE           reduce using rule 10 (statement -> while .)
    FOR             reduce using rule 10 (statement -> while .)
    PRINT           reduce using rule 10 (statement -> while .)
    CLASS           reduce using rule 10 (statement -> while .)
    ENUM            reduce using rule 10 (statement -> while .)
    TRY             reduce using rule 10 (statement -> while .)
    SWITCH          reduce using rule 10 (statement -> while .)
    INT_TYPE        reduce using rule 10 (statement -> while .)
    STRING_TYPE     reduce using rule 10 (statement -> while .)
    NUM_TYPE        reduce using rule 10 (statement -> while .)
    DOUBLE_TYPE     reduce using rule 10 (statement -> while .)
    BOOL_TYPE       reduce using rule 10 (statement -> while .)
    LIST_TYPE       reduce using rule 10 (statement -> while .)
    MAP_TYPE        reduce using rule 10 (statement -> while .)
    SET_TYPE        reduce using rule 10 (statement -> while .)
    VAR             reduce using rule 10 (statement -> while .)
    CONST           reduce using rule 10 (statement -> while .)
    FINAL           reduce using rule 10 (statement -> while .)
    VOID            reduce using rule 10 (statement -> while .)
    INT             reduce using rule 10 (statement -> while .)
    DOUBLE          reduce using rule 10 (statement -> while .)
    $end            reduce using rule 10 (statement -> while .)
    RBRACE          reduce using rule 10 (statement -> while .)
    BREAK           reduce using rule 10 (statement -> while .)


state 11

    (11) statement -> for .

    ID              reduce using rule 11 (statement -> for .)
    IF              reduce using rule 11 (statement -> for .)
    WHILE           reduce using rule 11 (statement -> for .)
    FOR             reduce using rule 11 (statement -> for .)
    PRINT           reduce using rule 11 (statement -> for .)
    CLASS           reduce using rule 11 (statement -> for .)
    ENUM            reduce using rule 11 (statement -> for .)
    TRY             reduce using rule 11 (statement -> for .)
    SWITCH          reduce using rule 11 (statement -> for .)
    INT_TYPE        reduce using rule 11 (statement -> for .)
    STRING_TYPE     reduce using rule 11 (statement -> for .)
    NUM_TYPE        reduce using rule 11 (statement -> for .)
    DOUBLE_TYPE     reduce using rule 11 (statement -> for .)
    BOOL_TYPE       reduce using rule 11 (statement -> for .)
    LIST_TYPE       reduce using rule 11 (statement -> for .)
    MAP_TYPE        reduce using rule 11 (statement -> for .)
    SET_TYPE        reduce using rule 11 (statement -> for .)
    VAR             reduce using rule 11 (statement -> for .)
    CONST           reduce using rule 11 (statement -> for .)
    FINAL           reduce using rule 11 (statement -> for .)
    VOID            reduce using rule 11 (statement -> for .)
    INT             reduce using rule 11 (statement -> for .)
    DOUBLE          reduce using rule 11 (statement -> for .)
    $end            reduce using rule 11 (statement -> for .)
    RBRACE          reduce using rule 11 (statement -> for .)
    BREAK           reduce using rule 11 (statement -> for .)


state 12

    (12) statement -> print .

    ID              reduce using rule 12 (statement -> print .)
    IF              reduce using rule 12 (statement -> print .)
    WHILE           reduce using rule 12 (statement -> print .)
    FOR             reduce using rule 12 (statement -> print .)
    PRINT           reduce using rule 12 (statement -> print .)
    CLASS           reduce using rule 12 (statement -> print .)
    ENUM            reduce using rule 12 (statement -> print .)
    TRY             reduce using rule 12 (statement -> print .)
    SWITCH          reduce using rule 12 (statement -> print .)
    INT_TYPE        reduce using rule 12 (statement -> print .)
    STRING_TYPE     reduce using rule 12 (statement -> print .)
    NUM_TYPE        reduce using rule 12 (statement -> print .)
    DOUBLE_TYPE     reduce using rule 12 (statement -> print .)
    BOOL_TYPE       reduce using rule 12 (statement -> print .)
    LIST_TYPE       reduce using rule 12 (statement -> print .)
    MAP_TYPE        reduce using rule 12 (statement -> print .)
    SET_TYPE        reduce using rule 12 (statement -> print .)
    VAR             reduce using rule 12 (statement -> print .)
    CONST           reduce using rule 12 (statement -> print .)
    FINAL           reduce using rule 12 (statement -> print .)
    VOID            reduce using rule 12 (statement -> print .)
    INT             reduce using rule 12 (statement -> print .)
    DOUBLE          reduce using rule 12 (statement -> print .)
    $end            reduce using rule 12 (statement -> print .)
    RBRACE          reduce using rule 12 (statement -> print .)
    BREAK           reduce using rule 12 (statement -> print .)


state 13

    (13) statement -> input .

    ID              reduce using rule 13 (statement -> input .)
    IF              reduce using rule 13 (statement -> input .)
    WHILE           reduce using rule 13 (statement -> input .)
    FOR             reduce using rule 13 (statement -> input .)
    PRINT           reduce using rule 13 (statement -> input .)
    CLASS           reduce using rule 13 (statement -> input .)
    ENUM            reduce using rule 13 (statement -> input .)
    TRY             reduce using rule 13 (statement -> input .)
    SWITCH          reduce using rule 13 (statement -> input .)
    INT_TYPE        reduce using rule 13 (statement -> input .)
    STRING_TYPE     reduce using rule 13 (statement -> input .)
    NUM_TYPE        reduce using rule 13 (statement -> input .)
    DOUBLE_TYPE     reduce using rule 13 (statement -> input .)
    BOOL_TYPE       reduce using rule 13 (statement -> input .)
    LIST_TYPE       reduce using rule 13 (statement -> input .)
    MAP_TYPE        reduce using rule 13 (statement -> input .)
    SET_TYPE        reduce using rule 13 (statement -> input .)
    VAR             reduce using rule 13 (statement -> input .)
    CONST           reduce using rule 13 (statement -> input .)
    FINAL           reduce using rule 13 (statement -> input .)
    VOID            reduce using rule 13 (statement -> input .)
    INT             reduce using rule 13 (statement -> input .)
    DOUBLE          reduce using rule 13 (statement -> input .)
    $end            reduce using rule 13 (statement -> input .)
    RBRACE          reduce using rule 13 (statement -> input .)
    BREAK           reduce using rule 13 (statement -> input .)


state 14

    (14) statement -> class_def .

    ID              reduce using rule 14 (statement -> class_def .)
    IF              reduce using rule 14 (statement -> class_def .)
    WHILE           reduce using rule 14 (statement -> class_def .)
    FOR             reduce using rule 14 (statement -> class_def .)
    PRINT           reduce using rule 14 (statement -> class_def .)
    CLASS           reduce using rule 14 (statement -> class_def .)
    ENUM            reduce using rule 14 (statement -> class_def .)
    TRY             reduce using rule 14 (statement -> class_def .)
    SWITCH          reduce using rule 14 (statement -> class_def .)
    INT_TYPE        reduce using rule 14 (statement -> class_def .)
    STRING_TYPE     reduce using rule 14 (statement -> class_def .)
    NUM_TYPE        reduce using rule 14 (statement -> class_def .)
    DOUBLE_TYPE     reduce using rule 14 (statement -> class_def .)
    BOOL_TYPE       reduce using rule 14 (statement -> class_def .)
    LIST_TYPE       reduce using rule 14 (statement -> class_def .)
    MAP_TYPE        reduce using rule 14 (statement -> class_def .)
    SET_TYPE        reduce using rule 14 (statement -> class_def .)
    VAR             reduce using rule 14 (statement -> class_def .)
    CONST           reduce using rule 14 (statement -> class_def .)
    FINAL           reduce using rule 14 (statement -> class_def .)
    VOID            reduce using rule 14 (statement -> class_def .)
    INT             reduce using rule 14 (statement -> class_def .)
    DOUBLE          reduce using rule 14 (statement -> class_def .)
    $end            reduce using rule 14 (statement -> class_def .)
    RBRACE          reduce using rule 14 (statement -> class_def .)
    BREAK           reduce using rule 14 (statement -> class_def .)


state 15

    (15) statement -> enum .

    ID              reduce using rule 15 (statement -> enum .)
    IF              reduce using rule 15 (statement -> enum .)
    WHILE           reduce using rule 15 (statement -> enum .)
    FOR             reduce using rule 15 (statement -> enum .)
    PRINT           reduce using rule 15 (statement -> enum .)
    CLASS           reduce using rule 15 (statement -> enum .)
    ENUM            reduce using rule 15 (statement -> enum .)
    TRY             reduce using rule 15 (statement -> enum .)
    SWITCH          reduce using rule 15 (statement -> enum .)
    INT_TYPE        reduce using rule 15 (statement -> enum .)
    STRING_TYPE     reduce using rule 15 (statement -> enum .)
    NUM_TYPE        reduce using rule 15 (statement -> enum .)
    DOUBLE_TYPE     reduce using rule 15 (statement -> enum .)
    BOOL_TYPE       reduce using rule 15 (statement -> enum .)
    LIST_TYPE       reduce using rule 15 (statement -> enum .)
    MAP_TYPE        reduce using rule 15 (statement -> enum .)
    SET_TYPE        reduce using rule 15 (statement -> enum .)
    VAR             reduce using rule 15 (statement -> enum .)
    CONST           reduce using rule 15 (statement -> enum .)
    FINAL           reduce using rule 15 (statement -> enum .)
    VOID            reduce using rule 15 (statement -> enum .)
    INT             reduce using rule 15 (statement -> enum .)
    DOUBLE          reduce using rule 15 (statement -> enum .)
    $end            reduce using rule 15 (statement -> enum .)
    RBRACE          reduce using rule 15 (statement -> enum .)
    BREAK           reduce using rule 15 (statement -> enum .)


state 16

    (16) statement -> try .

    ID              reduce using rule 16 (statement -> try .)
    IF              reduce using rule 16 (statement -> try .)
    WHILE           reduce using rule 16 (statement -> try .)
    FOR             reduce using rule 16 (statement -> try .)
    PRINT           reduce using rule 16 (statement -> try .)
    CLASS           reduce using rule 16 (statement -> try .)
    ENUM            reduce using rule 16 (statement -> try .)
    TRY             reduce using rule 16 (statement -> try .)
    SWITCH          reduce using rule 16 (statement -> try .)
    INT_TYPE        reduce using rule 16 (statement -> try .)
    STRING_TYPE     reduce using rule 16 (statement -> try .)
    NUM_TYPE        reduce using rule 16 (statement -> try .)
    DOUBLE_TYPE     reduce using rule 16 (statement -> try .)
    BOOL_TYPE       reduce using rule 16 (statement -> try .)
    LIST_TYPE       reduce using rule 16 (statement -> try .)
    MAP_TYPE        reduce using rule 16 (statement -> try .)
    SET_TYPE        reduce using rule 16 (statement -> try .)
    VAR             reduce using rule 16 (statement -> try .)
    CONST           reduce using rule 16 (statement -> try .)
    FINAL           reduce using rule 16 (statement -> try .)
    VOID            reduce using rule 16 (statement -> try .)
    INT             reduce using rule 16 (statement -> try .)
    DOUBLE          reduce using rule 16 (statement -> try .)
    $end            reduce using rule 16 (statement -> try .)
    RBRACE          reduce using rule 16 (statement -> try .)
    BREAK           reduce using rule 16 (statement -> try .)


state 17

    (17) statement -> switch .

    ID              reduce using rule 17 (statement -> switch .)
    IF              reduce using rule 17 (statement -> switch .)
    WHILE           reduce using rule 17 (statement -> switch .)
    FOR             reduce using rule 17 (statement -> switch .)
    PRINT           reduce using rule 17 (statement -> switch .)
    CLASS           reduce using rule 17 (statement -> switch .)
    ENUM            reduce using rule 17 (statement -> switch .)
    TRY             reduce using rule 17 (statement -> switch .)
    SWITCH          reduce using rule 17 (statement -> switch .)
    INT_TYPE        reduce using rule 17 (statement -> switch .)
    STRING_TYPE     reduce using rule 17 (statement -> switch .)
    NUM_TYPE        reduce using rule 17 (statement -> switch .)
    DOUBLE_TYPE     reduce using rule 17 (statement -> switch .)
    BOOL_TYPE       reduce using rule 17 (statement -> switch .)
    LIST_TYPE       reduce using rule 17 (statement -> switch .)
    MAP_TYPE        reduce using rule 17 (statement -> switch .)
    SET_TYPE        reduce using rule 17 (statement -> switch .)
    VAR             reduce using rule 17 (statement -> switch .)
    CONST           reduce using rule 17 (statement -> switch .)
    FINAL           reduce using rule 17 (statement -> switch .)
    VOID            reduce using rule 17 (statement -> switch .)
    INT             reduce using rule 17 (statement -> switch .)
    DOUBLE          reduce using rule 17 (statement -> switch .)
    $end            reduce using rule 17 (statement -> switch .)
    RBRACE          reduce using rule 17 (statement -> switch .)
    BREAK           reduce using rule 17 (statement -> switch .)


state 18

    (18) statement -> list .

    ID              reduce using rule 18 (statement -> list .)
    IF              reduce using rule 18 (statement -> list .)
    WHILE           reduce using rule 18 (statement -> list .)
    FOR             reduce using rule 18 (statement -> list .)
    PRINT           reduce using rule 18 (statement -> list .)
    CLASS           reduce using rule 18 (statement -> list .)
    ENUM            reduce using rule 18 (statement -> list .)
    TRY             reduce using rule 18 (statement -> list .)
    SWITCH          reduce using rule 18 (statement -> list .)
    INT_TYPE        reduce using rule 18 (statement -> list .)
    STRING_TYPE     reduce using rule 18 (statement -> list .)
    NUM_TYPE        reduce using rule 18 (statement -> list .)
    DOUBLE_TYPE     reduce using rule 18 (statement -> list .)
    BOOL_TYPE       reduce using rule 18 (statement -> list .)
    LIST_TYPE       reduce using rule 18 (statement -> list .)
    MAP_TYPE        reduce using rule 18 (statement -> list .)
    SET_TYPE        reduce using rule 18 (statement -> list .)
    VAR             reduce using rule 18 (statement -> list .)
    CONST           reduce using rule 18 (statement -> list .)
    FINAL           reduce using rule 18 (statement -> list .)
    VOID            reduce using rule 18 (statement -> list .)
    INT             reduce using rule 18 (statement -> list .)
    DOUBLE          reduce using rule 18 (statement -> list .)
    $end            reduce using rule 18 (statement -> list .)
    RBRACE          reduce using rule 18 (statement -> list .)
    BREAK           reduce using rule 18 (statement -> list .)


state 19

    (19) statement -> set .

    ID              reduce using rule 19 (statement -> set .)
    IF              reduce using rule 19 (statement -> set .)
    WHILE           reduce using rule 19 (statement -> set .)
    FOR             reduce using rule 19 (statement -> set .)
    PRINT           reduce using rule 19 (statement -> set .)
    CLASS           reduce using rule 19 (statement -> set .)
    ENUM            reduce using rule 19 (statement -> set .)
    TRY             reduce using rule 19 (statement -> set .)
    SWITCH          reduce using rule 19 (statement -> set .)
    INT_TYPE        reduce using rule 19 (statement -> set .)
    STRING_TYPE     reduce using rule 19 (statement -> set .)
    NUM_TYPE        reduce using rule 19 (statement -> set .)
    DOUBLE_TYPE     reduce using rule 19 (statement -> set .)
    BOOL_TYPE       reduce using rule 19 (statement -> set .)
    LIST_TYPE       reduce using rule 19 (statement -> set .)
    MAP_TYPE        reduce using rule 19 (statement -> set .)
    SET_TYPE        reduce using rule 19 (statement -> set .)
    VAR             reduce using rule 19 (statement -> set .)
    CONST           reduce using rule 19 (statement -> set .)
    FINAL           reduce using rule 19 (statement -> set .)
    VOID            reduce using rule 19 (statement -> set .)
    INT             reduce using rule 19 (statement -> set .)
    DOUBLE          reduce using rule 19 (statement -> set .)
    $end            reduce using rule 19 (statement -> set .)
    RBRACE          reduce using rule 19 (statement -> set .)
    BREAK           reduce using rule 19 (statement -> set .)


state 20

    (20) statement -> map .

    ID              reduce using rule 20 (statement -> map .)
    IF              reduce using rule 20 (statement -> map .)
    WHILE           reduce using rule 20 (statement -> map .)
    FOR             reduce using rule 20 (statement -> map .)
    PRINT           reduce using rule 20 (statement -> map .)
    CLASS           reduce using rule 20 (statement -> map .)
    ENUM            reduce using rule 20 (statement -> map .)
    TRY             reduce using rule 20 (statement -> map .)
    SWITCH          reduce using rule 20 (statement -> map .)
    INT_TYPE        reduce using rule 20 (statement -> map .)
    STRING_TYPE     reduce using rule 20 (statement -> map .)
    NUM_TYPE        reduce using rule 20 (statement -> map .)
    DOUBLE_TYPE     reduce using rule 20 (statement -> map .)
    BOOL_TYPE       reduce using rule 20 (statement -> map .)
    LIST_TYPE       reduce using rule 20 (statement -> map .)
    MAP_TYPE        reduce using rule 20 (statement -> map .)
    SET_TYPE        reduce using rule 20 (statement -> map .)
    VAR             reduce using rule 20 (statement -> map .)
    CONST           reduce using rule 20 (statement -> map .)
    FINAL           reduce using rule 20 (statement -> map .)
    VOID            reduce using rule 20 (statement -> map .)
    INT             reduce using rule 20 (statement -> map .)
    DOUBLE          reduce using rule 20 (statement -> map .)
    $end            reduce using rule 20 (statement -> map .)
    RBRACE          reduce using rule 20 (statement -> map .)
    BREAK           reduce using rule 20 (statement -> map .)


state 21

    (21) statement -> empty .
    (85) list -> empty .
    (86) set -> empty .
    (87) map -> empty .

  ! reduce/reduce conflict for ID resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for CLASS resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for ENUM resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for TRY resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for SWITCH resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for INT_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for NUM_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for BOOL_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for VAR resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for CONST resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for FINAL resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for VOID resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for INT resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for $end resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for CLASS resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for ENUM resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for TRY resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for SWITCH resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for INT_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for NUM_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for BOOL_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for VAR resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for CONST resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for FINAL resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for VOID resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for INT resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for $end resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for IF resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for WHILE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for FOR resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for PRINT resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for CLASS resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for ENUM resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for TRY resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for SWITCH resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for INT_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for STRING_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for NUM_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for DOUBLE_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for BOOL_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for LIST_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for MAP_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for SET_TYPE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for VAR resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for CONST resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for FINAL resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for VOID resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for INT resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for DOUBLE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for $end resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for RBRACE resolved using rule 21 (statement -> empty .)
  ! reduce/reduce conflict for BREAK resolved using rule 21 (statement -> empty .)
    ID              reduce using rule 21 (statement -> empty .)
    IF              reduce using rule 21 (statement -> empty .)
    WHILE           reduce using rule 21 (statement -> empty .)
    FOR             reduce using rule 21 (statement -> empty .)
    PRINT           reduce using rule 21 (statement -> empty .)
    CLASS           reduce using rule 21 (statement -> empty .)
    ENUM            reduce using rule 21 (statement -> empty .)
    TRY             reduce using rule 21 (statement -> empty .)
    SWITCH          reduce using rule 21 (statement -> empty .)
    INT_TYPE        reduce using rule 21 (statement -> empty .)
    STRING_TYPE     reduce using rule 21 (statement -> empty .)
    NUM_TYPE        reduce using rule 21 (statement -> empty .)
    DOUBLE_TYPE     reduce using rule 21 (statement -> empty .)
    BOOL_TYPE       reduce using rule 21 (statement -> empty .)
    LIST_TYPE       reduce using rule 21 (statement -> empty .)
    MAP_TYPE        reduce using rule 21 (statement -> empty .)
    SET_TYPE        reduce using rule 21 (statement -> empty .)
    VAR             reduce using rule 21 (statement -> empty .)
    CONST           reduce using rule 21 (statement -> empty .)
    FINAL           reduce using rule 21 (statement -> empty .)
    VOID            reduce using rule 21 (statement -> empty .)
    INT             reduce using rule 21 (statement -> empty .)
    DOUBLE          reduce using rule 21 (statement -> empty .)
    $end            reduce using rule 21 (statement -> empty .)
    RBRACE          reduce using rule 21 (statement -> empty .)
    BREAK           reduce using rule 21 (statement -> empty .)

  ! ID              [ reduce using rule 85 (list -> empty .) ]
  ! IF              [ reduce using rule 85 (list -> empty .) ]
  ! WHILE           [ reduce using rule 85 (list -> empty .) ]
  ! FOR             [ reduce using rule 85 (list -> empty .) ]
  ! PRINT           [ reduce using rule 85 (list -> empty .) ]
  ! CLASS           [ reduce using rule 85 (list -> empty .) ]
  ! ENUM            [ reduce using rule 85 (list -> empty .) ]
  ! TRY             [ reduce using rule 85 (list -> empty .) ]
  ! SWITCH          [ reduce using rule 85 (list -> empty .) ]
  ! INT_TYPE        [ reduce using rule 85 (list -> empty .) ]
  ! STRING_TYPE     [ reduce using rule 85 (list -> empty .) ]
  ! NUM_TYPE        [ reduce using rule 85 (list -> empty .) ]
  ! DOUBLE_TYPE     [ reduce using rule 85 (list -> empty .) ]
  ! BOOL_TYPE       [ reduce using rule 85 (list -> empty .) ]
  ! LIST_TYPE       [ reduce using rule 85 (list -> empty .) ]
  ! MAP_TYPE        [ reduce using rule 85 (list -> empty .) ]
  ! SET_TYPE        [ reduce using rule 85 (list -> empty .) ]
  ! VAR             [ reduce using rule 85 (list -> empty .) ]
  ! CONST           [ reduce using rule 85 (list -> empty .) ]
  ! FINAL           [ reduce using rule 85 (list -> empty .) ]
  ! VOID            [ reduce using rule 85 (list -> empty .) ]
  ! INT             [ reduce using rule 85 (list -> empty .) ]
  ! DOUBLE          [ reduce using rule 85 (list -> empty .) ]
  ! $end            [ reduce using rule 85 (list -> empty .) ]
  ! RBRACE          [ reduce using rule 85 (list -> empty .) ]
  ! BREAK           [ reduce using rule 85 (list -> empty .) ]
  ! ID              [ reduce using rule 86 (set -> empty .) ]
  ! IF              [ reduce using rule 86 (set -> empty .) ]
  ! WHILE           [ reduce using rule 86 (set -> empty .) ]
  ! FOR             [ reduce using rule 86 (set -> empty .) ]
  ! PRINT           [ reduce using rule 86 (set -> empty .) ]
  ! CLASS           [ reduce using rule 86 (set -> empty .) ]
  ! ENUM            [ reduce using rule 86 (set -> empty .) ]
  ! TRY             [ reduce using rule 86 (set -> empty .) ]
  ! SWITCH          [ reduce using rule 86 (set -> empty .) ]
  ! INT_TYPE        [ reduce using rule 86 (set -> empty .) ]
  ! STRING_TYPE     [ reduce using rule 86 (set -> empty .) ]
  ! NUM_TYPE        [ reduce using rule 86 (set -> empty .) ]
  ! DOUBLE_TYPE     [ reduce using rule 86 (set -> empty .) ]
  ! BOOL_TYPE       [ reduce using rule 86 (set -> empty .) ]
  ! LIST_TYPE       [ reduce using rule 86 (set -> empty .) ]
  ! MAP_TYPE        [ reduce using rule 86 (set -> empty .) ]
  ! SET_TYPE        [ reduce using rule 86 (set -> empty .) ]
  ! VAR             [ reduce using rule 86 (set -> empty .) ]
  ! CONST           [ reduce using rule 86 (set -> empty .) ]
  ! FINAL           [ reduce using rule 86 (set -> empty .) ]
  ! VOID            [ reduce using rule 86 (set -> empty .) ]
  ! INT             [ reduce using rule 86 (set -> empty .) ]
  ! DOUBLE          [ reduce using rule 86 (set -> empty .) ]
  ! $end            [ reduce using rule 86 (set -> empty .) ]
  ! RBRACE          [ reduce using rule 86 (set -> empty .) ]
  ! BREAK           [ reduce using rule 86 (set -> empty .) ]
  ! ID              [ reduce using rule 87 (map -> empty .) ]
  ! IF              [ reduce using rule 87 (map -> empty .) ]
  ! WHILE           [ reduce using rule 87 (map -> empty .) ]
  ! FOR             [ reduce using rule 87 (map -> empty .) ]
  ! PRINT           [ reduce using rule 87 (map -> empty .) ]
  ! CLASS           [ reduce using rule 87 (map -> empty .) ]
  ! ENUM            [ reduce using rule 87 (map -> empty .) ]
  ! TRY             [ reduce using rule 87 (map -> empty .) ]
  ! SWITCH          [ reduce using rule 87 (map -> empty .) ]
  ! INT_TYPE        [ reduce using rule 87 (map -> empty .) ]
  ! STRING_TYPE     [ reduce using rule 87 (map -> empty .) ]
  ! NUM_TYPE        [ reduce using rule 87 (map -> empty .) ]
  ! DOUBLE_TYPE     [ reduce using rule 87 (map -> empty .) ]
  ! BOOL_TYPE       [ reduce using rule 87 (map -> empty .) ]
  ! LIST_TYPE       [ reduce using rule 87 (map -> empty .) ]
  ! MAP_TYPE        [ reduce using rule 87 (map -> empty .) ]
  ! SET_TYPE        [ reduce using rule 87 (map -> empty .) ]
  ! VAR             [ reduce using rule 87 (map -> empty .) ]
  ! CONST           [ reduce using rule 87 (map -> empty .) ]
  ! FINAL           [ reduce using rule 87 (map -> empty .) ]
  ! VOID            [ reduce using rule 87 (map -> empty .) ]
  ! INT             [ reduce using rule 87 (map -> empty .) ]
  ! DOUBLE          [ reduce using rule 87 (map -> empty .) ]
  ! $end            [ reduce using rule 87 (map -> empty .) ]
  ! RBRACE          [ reduce using rule 87 (map -> empty .) ]
  ! BREAK           [ reduce using rule 87 (map -> empty .) ]


state 22

    (27) expression -> term .
    (28) term -> term . TIMES factor
    (29) term -> term . DIVIDE factor
    (30) term -> term . MODULE factor

    SEMICOLON       reduce using rule 27 (expression -> term .)
    PLUS            reduce using rule 27 (expression -> term .)
    MINUS           reduce using rule 27 (expression -> term .)
    EQUALS          reduce using rule 27 (expression -> term .)
    NOT_EQUALS      reduce using rule 27 (expression -> term .)
    GREATER_THAN    reduce using rule 27 (expression -> term .)
    LESS_THAN       reduce using rule 27 (expression -> term .)
    GREATER_THAN_OR_EQUALS reduce using rule 27 (expression -> term .)
    LESS_THAN_OR_EQUALS reduce using rule 27 (expression -> term .)
    RPARENTHESIS    reduce using rule 27 (expression -> term .)
    COLON           reduce using rule 27 (expression -> term .)
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MODULE          shift and go to state 54


state 23

    (22) declaration -> varType . ID SEMICOLON
    (23) assignation -> varType . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> varType . ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE

    ID              shift and go to state 55


state 24

    (24) assignation_no_type -> ID . ASSIGN_OPERATOR variable SEMICOLON
    (65) input -> ID . ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON

    ASSIGN_OPERATOR shift and go to state 56


state 25

    (59) if -> IF . LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> IF . LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE

    LPARENTHESIS    shift and go to state 57


state 26

    (61) while -> WHILE . LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE

    LPARENTHESIS    shift and go to state 58


state 27

    (62) for -> FOR . LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE

    LPARENTHESIS    shift and go to state 59


state 28

    (64) print -> PRINT . LPARENTHESIS expression RPARENTHESIS SEMICOLON

    LPARENTHESIS    shift and go to state 60


state 29

    (66) class_def -> CLASS . ID LBRACE class_members RBRACE

    ID              shift and go to state 61


state 30

    (72) enum -> ENUM . ID LBRACE enum_values RBRACE

    ID              shift and go to state 62


state 31

    (75) try -> TRY . LBRACE statements RBRACE FINALLY LBRACE statements RBRACE

    LBRACE          shift and go to state 63


state 32

    (76) switch -> SWITCH . LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE

    LPARENTHESIS    shift and go to state 64


state 33

    (31) term -> factor .

    TIMES           reduce using rule 31 (term -> factor .)
    DIVIDE          reduce using rule 31 (term -> factor .)
    MODULE          reduce using rule 31 (term -> factor .)
    SEMICOLON       reduce using rule 31 (term -> factor .)
    PLUS            reduce using rule 31 (term -> factor .)
    MINUS           reduce using rule 31 (term -> factor .)
    EQUALS          reduce using rule 31 (term -> factor .)
    NOT_EQUALS      reduce using rule 31 (term -> factor .)
    GREATER_THAN    reduce using rule 31 (term -> factor .)
    LESS_THAN       reduce using rule 31 (term -> factor .)
    GREATER_THAN_OR_EQUALS reduce using rule 31 (term -> factor .)
    LESS_THAN_OR_EQUALS reduce using rule 31 (term -> factor .)
    RPARENTHESIS    reduce using rule 31 (term -> factor .)
    COLON           reduce using rule 31 (term -> factor .)


state 34

    (41) varType -> INT_TYPE .

    ID              reduce using rule 41 (varType -> INT_TYPE .)


state 35

    (42) varType -> STRING_TYPE .

    ID              reduce using rule 42 (varType -> STRING_TYPE .)


state 36

    (43) varType -> NUM_TYPE .

    ID              reduce using rule 43 (varType -> NUM_TYPE .)


state 37

    (44) varType -> DOUBLE_TYPE .

    ID              reduce using rule 44 (varType -> DOUBLE_TYPE .)


state 38

    (45) varType -> BOOL_TYPE .

    ID              reduce using rule 45 (varType -> BOOL_TYPE .)


state 39

    (46) varType -> LIST_TYPE .

    ID              reduce using rule 46 (varType -> LIST_TYPE .)


state 40

    (47) varType -> MAP_TYPE .

    ID              reduce using rule 47 (varType -> MAP_TYPE .)


state 41

    (48) varType -> SET_TYPE .

    ID              reduce using rule 48 (varType -> SET_TYPE .)


state 42

    (49) varType -> VAR .

    ID              reduce using rule 49 (varType -> VAR .)


state 43

    (50) varType -> CONST .

    ID              reduce using rule 50 (varType -> CONST .)


state 44

    (51) varType -> FINAL .

    ID              reduce using rule 51 (varType -> FINAL .)


state 45

    (52) varType -> VOID .

    ID              reduce using rule 52 (varType -> VOID .)


state 46

    (32) factor -> INT .

    TIMES           reduce using rule 32 (factor -> INT .)
    DIVIDE          reduce using rule 32 (factor -> INT .)
    MODULE          reduce using rule 32 (factor -> INT .)
    SEMICOLON       reduce using rule 32 (factor -> INT .)
    PLUS            reduce using rule 32 (factor -> INT .)
    MINUS           reduce using rule 32 (factor -> INT .)
    EQUALS          reduce using rule 32 (factor -> INT .)
    NOT_EQUALS      reduce using rule 32 (factor -> INT .)
    GREATER_THAN    reduce using rule 32 (factor -> INT .)
    LESS_THAN       reduce using rule 32 (factor -> INT .)
    GREATER_THAN_OR_EQUALS reduce using rule 32 (factor -> INT .)
    LESS_THAN_OR_EQUALS reduce using rule 32 (factor -> INT .)
    RPARENTHESIS    reduce using rule 32 (factor -> INT .)
    COLON           reduce using rule 32 (factor -> INT .)


state 47

    (33) factor -> DOUBLE .

    TIMES           reduce using rule 33 (factor -> DOUBLE .)
    DIVIDE          reduce using rule 33 (factor -> DOUBLE .)
    MODULE          reduce using rule 33 (factor -> DOUBLE .)
    SEMICOLON       reduce using rule 33 (factor -> DOUBLE .)
    PLUS            reduce using rule 33 (factor -> DOUBLE .)
    MINUS           reduce using rule 33 (factor -> DOUBLE .)
    EQUALS          reduce using rule 33 (factor -> DOUBLE .)
    NOT_EQUALS      reduce using rule 33 (factor -> DOUBLE .)
    GREATER_THAN    reduce using rule 33 (factor -> DOUBLE .)
    LESS_THAN       reduce using rule 33 (factor -> DOUBLE .)
    GREATER_THAN_OR_EQUALS reduce using rule 33 (factor -> DOUBLE .)
    LESS_THAN_OR_EQUALS reduce using rule 33 (factor -> DOUBLE .)
    RPARENTHESIS    reduce using rule 33 (factor -> DOUBLE .)
    COLON           reduce using rule 33 (factor -> DOUBLE .)


state 48

    (2) statements -> statements statement .

    ID              reduce using rule 2 (statements -> statements statement .)
    IF              reduce using rule 2 (statements -> statements statement .)
    WHILE           reduce using rule 2 (statements -> statements statement .)
    FOR             reduce using rule 2 (statements -> statements statement .)
    PRINT           reduce using rule 2 (statements -> statements statement .)
    CLASS           reduce using rule 2 (statements -> statements statement .)
    ENUM            reduce using rule 2 (statements -> statements statement .)
    TRY             reduce using rule 2 (statements -> statements statement .)
    SWITCH          reduce using rule 2 (statements -> statements statement .)
    INT_TYPE        reduce using rule 2 (statements -> statements statement .)
    STRING_TYPE     reduce using rule 2 (statements -> statements statement .)
    NUM_TYPE        reduce using rule 2 (statements -> statements statement .)
    DOUBLE_TYPE     reduce using rule 2 (statements -> statements statement .)
    BOOL_TYPE       reduce using rule 2 (statements -> statements statement .)
    LIST_TYPE       reduce using rule 2 (statements -> statements statement .)
    MAP_TYPE        reduce using rule 2 (statements -> statements statement .)
    SET_TYPE        reduce using rule 2 (statements -> statements statement .)
    VAR             reduce using rule 2 (statements -> statements statement .)
    CONST           reduce using rule 2 (statements -> statements statement .)
    FINAL           reduce using rule 2 (statements -> statements statement .)
    VOID            reduce using rule 2 (statements -> statements statement .)
    INT             reduce using rule 2 (statements -> statements statement .)
    DOUBLE          reduce using rule 2 (statements -> statements statement .)
    $end            reduce using rule 2 (statements -> statements statement .)
    RBRACE          reduce using rule 2 (statements -> statements statement .)
    BREAK           reduce using rule 2 (statements -> statements statement .)


state 49

    (4) statement -> expression SEMICOLON .

    ID              reduce using rule 4 (statement -> expression SEMICOLON .)
    IF              reduce using rule 4 (statement -> expression SEMICOLON .)
    WHILE           reduce using rule 4 (statement -> expression SEMICOLON .)
    FOR             reduce using rule 4 (statement -> expression SEMICOLON .)
    PRINT           reduce using rule 4 (statement -> expression SEMICOLON .)
    CLASS           reduce using rule 4 (statement -> expression SEMICOLON .)
    ENUM            reduce using rule 4 (statement -> expression SEMICOLON .)
    TRY             reduce using rule 4 (statement -> expression SEMICOLON .)
    SWITCH          reduce using rule 4 (statement -> expression SEMICOLON .)
    INT_TYPE        reduce using rule 4 (statement -> expression SEMICOLON .)
    STRING_TYPE     reduce using rule 4 (statement -> expression SEMICOLON .)
    NUM_TYPE        reduce using rule 4 (statement -> expression SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 4 (statement -> expression SEMICOLON .)
    BOOL_TYPE       reduce using rule 4 (statement -> expression SEMICOLON .)
    LIST_TYPE       reduce using rule 4 (statement -> expression SEMICOLON .)
    MAP_TYPE        reduce using rule 4 (statement -> expression SEMICOLON .)
    SET_TYPE        reduce using rule 4 (statement -> expression SEMICOLON .)
    VAR             reduce using rule 4 (statement -> expression SEMICOLON .)
    CONST           reduce using rule 4 (statement -> expression SEMICOLON .)
    FINAL           reduce using rule 4 (statement -> expression SEMICOLON .)
    VOID            reduce using rule 4 (statement -> expression SEMICOLON .)
    INT             reduce using rule 4 (statement -> expression SEMICOLON .)
    DOUBLE          reduce using rule 4 (statement -> expression SEMICOLON .)
    $end            reduce using rule 4 (statement -> expression SEMICOLON .)
    RBRACE          reduce using rule 4 (statement -> expression SEMICOLON .)
    BREAK           reduce using rule 4 (statement -> expression SEMICOLON .)


state 50

    (25) expression -> expression PLUS . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

    term                           shift and go to state 65
    factor                         shift and go to state 33

state 51

    (26) expression -> expression MINUS . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

    term                           shift and go to state 66
    factor                         shift and go to state 33

state 52

    (28) term -> term TIMES . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

    factor                         shift and go to state 67

state 53

    (29) term -> term DIVIDE . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

    factor                         shift and go to state 68

state 54

    (30) term -> term MODULE . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

    factor                         shift and go to state 69

state 55

    (22) declaration -> varType ID . SEMICOLON
    (23) assignation -> varType ID . ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> varType ID . LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE

    SEMICOLON       shift and go to state 70
    ASSIGN_OPERATOR shift and go to state 71
    LPARENTHESIS    shift and go to state 72


state 56

    (24) assignation_no_type -> ID ASSIGN_OPERATOR . variable SEMICOLON
    (65) input -> ID ASSIGN_OPERATOR . STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (34) variable -> . INT
    (35) variable -> . DOUBLE
    (36) variable -> . STRING
    (37) variable -> . BOOL
    (38) variable -> . NULL
    (39) variable -> . ID
    (40) variable -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    STDIN           shift and go to state 75
    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 79
    NULL            shift and go to state 80
    ID              shift and go to state 73

    variable                       shift and go to state 74
    expression                     shift and go to state 81
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 57

    (59) if -> IF LPARENTHESIS . booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> IF LPARENTHESIS . booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (53) booleanExpression -> . variable EQUALS variable
    (54) booleanExpression -> . variable NOT_EQUALS variable
    (55) booleanExpression -> . variable GREATER_THAN variable
    (56) booleanExpression -> . variable LESS_THAN variable
    (57) booleanExpression -> . variable GREATER_THAN_OR_EQUALS variable
    (58) booleanExpression -> . variable LESS_THAN_OR_EQUALS variable
    (34) variable -> . INT
    (35) variable -> . DOUBLE
    (36) variable -> . STRING
    (37) variable -> . BOOL
    (38) variable -> . NULL
    (39) variable -> . ID
    (40) variable -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 79
    NULL            shift and go to state 80
    ID              shift and go to state 73

    booleanExpression              shift and go to state 82
    variable                       shift and go to state 83
    expression                     shift and go to state 81
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 58

    (61) while -> WHILE LPARENTHESIS . booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (53) booleanExpression -> . variable EQUALS variable
    (54) booleanExpression -> . variable NOT_EQUALS variable
    (55) booleanExpression -> . variable GREATER_THAN variable
    (56) booleanExpression -> . variable LESS_THAN variable
    (57) booleanExpression -> . variable GREATER_THAN_OR_EQUALS variable
    (58) booleanExpression -> . variable LESS_THAN_OR_EQUALS variable
    (34) variable -> . INT
    (35) variable -> . DOUBLE
    (36) variable -> . STRING
    (37) variable -> . BOOL
    (38) variable -> . NULL
    (39) variable -> . ID
    (40) variable -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 79
    NULL            shift and go to state 80
    ID              shift and go to state 73

    booleanExpression              shift and go to state 84
    variable                       shift and go to state 83
    expression                     shift and go to state 81
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 59

    (62) for -> FOR LPARENTHESIS . assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID

    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45

    assignation                    shift and go to state 85
    varType                        shift and go to state 86

state 60

    (64) print -> PRINT LPARENTHESIS . expression RPARENTHESIS SEMICOLON
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

    expression                     shift and go to state 87
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 61

    (66) class_def -> CLASS ID . LBRACE class_members RBRACE

    LBRACE          shift and go to state 88


state 62

    (72) enum -> ENUM ID . LBRACE enum_values RBRACE

    LBRACE          shift and go to state 89


state 63

    (75) try -> TRY LBRACE . statements RBRACE FINALLY LBRACE statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    RBRACE          reduce using rule 88 (empty -> .)
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    statements                     shift and go to state 90
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 64

    (76) switch -> SWITCH LPARENTHESIS . variable RPARENTHESIS LBRACE cases default_case RBRACE
    (34) variable -> . INT
    (35) variable -> . DOUBLE
    (36) variable -> . STRING
    (37) variable -> . BOOL
    (38) variable -> . NULL
    (39) variable -> . ID
    (40) variable -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 79
    NULL            shift and go to state 80
    ID              shift and go to state 73

    variable                       shift and go to state 91
    expression                     shift and go to state 81
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 65

    (25) expression -> expression PLUS term .
    (28) term -> term . TIMES factor
    (29) term -> term . DIVIDE factor
    (30) term -> term . MODULE factor

    SEMICOLON       reduce using rule 25 (expression -> expression PLUS term .)
    PLUS            reduce using rule 25 (expression -> expression PLUS term .)
    MINUS           reduce using rule 25 (expression -> expression PLUS term .)
    EQUALS          reduce using rule 25 (expression -> expression PLUS term .)
    NOT_EQUALS      reduce using rule 25 (expression -> expression PLUS term .)
    GREATER_THAN    reduce using rule 25 (expression -> expression PLUS term .)
    LESS_THAN       reduce using rule 25 (expression -> expression PLUS term .)
    GREATER_THAN_OR_EQUALS reduce using rule 25 (expression -> expression PLUS term .)
    LESS_THAN_OR_EQUALS reduce using rule 25 (expression -> expression PLUS term .)
    RPARENTHESIS    reduce using rule 25 (expression -> expression PLUS term .)
    COLON           reduce using rule 25 (expression -> expression PLUS term .)
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MODULE          shift and go to state 54


state 66

    (26) expression -> expression MINUS term .
    (28) term -> term . TIMES factor
    (29) term -> term . DIVIDE factor
    (30) term -> term . MODULE factor

    SEMICOLON       reduce using rule 26 (expression -> expression MINUS term .)
    PLUS            reduce using rule 26 (expression -> expression MINUS term .)
    MINUS           reduce using rule 26 (expression -> expression MINUS term .)
    EQUALS          reduce using rule 26 (expression -> expression MINUS term .)
    NOT_EQUALS      reduce using rule 26 (expression -> expression MINUS term .)
    GREATER_THAN    reduce using rule 26 (expression -> expression MINUS term .)
    LESS_THAN       reduce using rule 26 (expression -> expression MINUS term .)
    GREATER_THAN_OR_EQUALS reduce using rule 26 (expression -> expression MINUS term .)
    LESS_THAN_OR_EQUALS reduce using rule 26 (expression -> expression MINUS term .)
    RPARENTHESIS    reduce using rule 26 (expression -> expression MINUS term .)
    COLON           reduce using rule 26 (expression -> expression MINUS term .)
    TIMES           shift and go to state 52
    DIVIDE          shift and go to state 53
    MODULE          shift and go to state 54


state 67

    (28) term -> term TIMES factor .

    TIMES           reduce using rule 28 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 28 (term -> term TIMES factor .)
    MODULE          reduce using rule 28 (term -> term TIMES factor .)
    SEMICOLON       reduce using rule 28 (term -> term TIMES factor .)
    PLUS            reduce using rule 28 (term -> term TIMES factor .)
    MINUS           reduce using rule 28 (term -> term TIMES factor .)
    EQUALS          reduce using rule 28 (term -> term TIMES factor .)
    NOT_EQUALS      reduce using rule 28 (term -> term TIMES factor .)
    GREATER_THAN    reduce using rule 28 (term -> term TIMES factor .)
    LESS_THAN       reduce using rule 28 (term -> term TIMES factor .)
    GREATER_THAN_OR_EQUALS reduce using rule 28 (term -> term TIMES factor .)
    LESS_THAN_OR_EQUALS reduce using rule 28 (term -> term TIMES factor .)
    RPARENTHESIS    reduce using rule 28 (term -> term TIMES factor .)
    COLON           reduce using rule 28 (term -> term TIMES factor .)


state 68

    (29) term -> term DIVIDE factor .

    TIMES           reduce using rule 29 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 29 (term -> term DIVIDE factor .)
    MODULE          reduce using rule 29 (term -> term DIVIDE factor .)
    SEMICOLON       reduce using rule 29 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 29 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 29 (term -> term DIVIDE factor .)
    EQUALS          reduce using rule 29 (term -> term DIVIDE factor .)
    NOT_EQUALS      reduce using rule 29 (term -> term DIVIDE factor .)
    GREATER_THAN    reduce using rule 29 (term -> term DIVIDE factor .)
    LESS_THAN       reduce using rule 29 (term -> term DIVIDE factor .)
    GREATER_THAN_OR_EQUALS reduce using rule 29 (term -> term DIVIDE factor .)
    LESS_THAN_OR_EQUALS reduce using rule 29 (term -> term DIVIDE factor .)
    RPARENTHESIS    reduce using rule 29 (term -> term DIVIDE factor .)
    COLON           reduce using rule 29 (term -> term DIVIDE factor .)


state 69

    (30) term -> term MODULE factor .

    TIMES           reduce using rule 30 (term -> term MODULE factor .)
    DIVIDE          reduce using rule 30 (term -> term MODULE factor .)
    MODULE          reduce using rule 30 (term -> term MODULE factor .)
    SEMICOLON       reduce using rule 30 (term -> term MODULE factor .)
    PLUS            reduce using rule 30 (term -> term MODULE factor .)
    MINUS           reduce using rule 30 (term -> term MODULE factor .)
    EQUALS          reduce using rule 30 (term -> term MODULE factor .)
    NOT_EQUALS      reduce using rule 30 (term -> term MODULE factor .)
    GREATER_THAN    reduce using rule 30 (term -> term MODULE factor .)
    LESS_THAN       reduce using rule 30 (term -> term MODULE factor .)
    GREATER_THAN_OR_EQUALS reduce using rule 30 (term -> term MODULE factor .)
    LESS_THAN_OR_EQUALS reduce using rule 30 (term -> term MODULE factor .)
    RPARENTHESIS    reduce using rule 30 (term -> term MODULE factor .)
    COLON           reduce using rule 30 (term -> term MODULE factor .)


state 70

    (22) declaration -> varType ID SEMICOLON .

    ID              reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    IF              reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    WHILE           reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    FOR             reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    PRINT           reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    CLASS           reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    ENUM            reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    TRY             reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    SWITCH          reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    INT_TYPE        reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    STRING_TYPE     reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    NUM_TYPE        reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    BOOL_TYPE       reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    LIST_TYPE       reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    MAP_TYPE        reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    SET_TYPE        reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    VAR             reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    CONST           reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    FINAL           reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    VOID            reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    INT             reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    DOUBLE          reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    $end            reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    RBRACE          reduce using rule 22 (declaration -> varType ID SEMICOLON .)
    BREAK           reduce using rule 22 (declaration -> varType ID SEMICOLON .)


state 71

    (23) assignation -> varType ID ASSIGN_OPERATOR . variable SEMICOLON
    (34) variable -> . INT
    (35) variable -> . DOUBLE
    (36) variable -> . STRING
    (37) variable -> . BOOL
    (38) variable -> . NULL
    (39) variable -> . ID
    (40) variable -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 79
    NULL            shift and go to state 80
    ID              shift and go to state 73

    variable                       shift and go to state 92
    expression                     shift and go to state 81
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 72

    (71) function -> varType ID LPARENTHESIS . parameters RPARENTHESIS LBRACE statements RBRACE
    (81) parameters -> . parameters COMMA parameter
    (82) parameters -> . parameter
    (83) parameters -> . empty
    (84) parameter -> . varType ID
    (88) empty -> .
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID

    RPARENTHESIS    reduce using rule 88 (empty -> .)
    COMMA           reduce using rule 88 (empty -> .)
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45

    varType                        shift and go to state 93
    parameters                     shift and go to state 94
    parameter                      shift and go to state 95
    empty                          shift and go to state 96

state 73

    (39) variable -> ID .

    SEMICOLON       reduce using rule 39 (variable -> ID .)
    EQUALS          reduce using rule 39 (variable -> ID .)
    NOT_EQUALS      reduce using rule 39 (variable -> ID .)
    GREATER_THAN    reduce using rule 39 (variable -> ID .)
    LESS_THAN       reduce using rule 39 (variable -> ID .)
    GREATER_THAN_OR_EQUALS reduce using rule 39 (variable -> ID .)
    LESS_THAN_OR_EQUALS reduce using rule 39 (variable -> ID .)
    RPARENTHESIS    reduce using rule 39 (variable -> ID .)
    COLON           reduce using rule 39 (variable -> ID .)


state 74

    (24) assignation_no_type -> ID ASSIGN_OPERATOR variable . SEMICOLON

    SEMICOLON       shift and go to state 97


state 75

    (65) input -> ID ASSIGN_OPERATOR STDIN . DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON

    DOT             shift and go to state 98


state 76

    (34) variable -> INT .
    (32) factor -> INT .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 32 (factor -> INT .)
  ! reduce/reduce conflict for EQUALS resolved using rule 32 (factor -> INT .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 32 (factor -> INT .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 32 (factor -> INT .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 32 (factor -> INT .)
  ! reduce/reduce conflict for GREATER_THAN_OR_EQUALS resolved using rule 32 (factor -> INT .)
  ! reduce/reduce conflict for LESS_THAN_OR_EQUALS resolved using rule 32 (factor -> INT .)
  ! reduce/reduce conflict for RPARENTHESIS resolved using rule 32 (factor -> INT .)
  ! reduce/reduce conflict for COLON resolved using rule 32 (factor -> INT .)
    TIMES           reduce using rule 32 (factor -> INT .)
    DIVIDE          reduce using rule 32 (factor -> INT .)
    MODULE          reduce using rule 32 (factor -> INT .)
    PLUS            reduce using rule 32 (factor -> INT .)
    MINUS           reduce using rule 32 (factor -> INT .)
    SEMICOLON       reduce using rule 32 (factor -> INT .)
    EQUALS          reduce using rule 32 (factor -> INT .)
    NOT_EQUALS      reduce using rule 32 (factor -> INT .)
    GREATER_THAN    reduce using rule 32 (factor -> INT .)
    LESS_THAN       reduce using rule 32 (factor -> INT .)
    GREATER_THAN_OR_EQUALS reduce using rule 32 (factor -> INT .)
    LESS_THAN_OR_EQUALS reduce using rule 32 (factor -> INT .)
    RPARENTHESIS    reduce using rule 32 (factor -> INT .)
    COLON           reduce using rule 32 (factor -> INT .)

  ! SEMICOLON       [ reduce using rule 34 (variable -> INT .) ]
  ! EQUALS          [ reduce using rule 34 (variable -> INT .) ]
  ! NOT_EQUALS      [ reduce using rule 34 (variable -> INT .) ]
  ! GREATER_THAN    [ reduce using rule 34 (variable -> INT .) ]
  ! LESS_THAN       [ reduce using rule 34 (variable -> INT .) ]
  ! GREATER_THAN_OR_EQUALS [ reduce using rule 34 (variable -> INT .) ]
  ! LESS_THAN_OR_EQUALS [ reduce using rule 34 (variable -> INT .) ]
  ! RPARENTHESIS    [ reduce using rule 34 (variable -> INT .) ]
  ! COLON           [ reduce using rule 34 (variable -> INT .) ]


state 77

    (35) variable -> DOUBLE .
    (33) factor -> DOUBLE .

  ! reduce/reduce conflict for SEMICOLON resolved using rule 33 (factor -> DOUBLE .)
  ! reduce/reduce conflict for EQUALS resolved using rule 33 (factor -> DOUBLE .)
  ! reduce/reduce conflict for NOT_EQUALS resolved using rule 33 (factor -> DOUBLE .)
  ! reduce/reduce conflict for GREATER_THAN resolved using rule 33 (factor -> DOUBLE .)
  ! reduce/reduce conflict for LESS_THAN resolved using rule 33 (factor -> DOUBLE .)
  ! reduce/reduce conflict for GREATER_THAN_OR_EQUALS resolved using rule 33 (factor -> DOUBLE .)
  ! reduce/reduce conflict for LESS_THAN_OR_EQUALS resolved using rule 33 (factor -> DOUBLE .)
  ! reduce/reduce conflict for RPARENTHESIS resolved using rule 33 (factor -> DOUBLE .)
  ! reduce/reduce conflict for COLON resolved using rule 33 (factor -> DOUBLE .)
    TIMES           reduce using rule 33 (factor -> DOUBLE .)
    DIVIDE          reduce using rule 33 (factor -> DOUBLE .)
    MODULE          reduce using rule 33 (factor -> DOUBLE .)
    PLUS            reduce using rule 33 (factor -> DOUBLE .)
    MINUS           reduce using rule 33 (factor -> DOUBLE .)
    SEMICOLON       reduce using rule 33 (factor -> DOUBLE .)
    EQUALS          reduce using rule 33 (factor -> DOUBLE .)
    NOT_EQUALS      reduce using rule 33 (factor -> DOUBLE .)
    GREATER_THAN    reduce using rule 33 (factor -> DOUBLE .)
    LESS_THAN       reduce using rule 33 (factor -> DOUBLE .)
    GREATER_THAN_OR_EQUALS reduce using rule 33 (factor -> DOUBLE .)
    LESS_THAN_OR_EQUALS reduce using rule 33 (factor -> DOUBLE .)
    RPARENTHESIS    reduce using rule 33 (factor -> DOUBLE .)
    COLON           reduce using rule 33 (factor -> DOUBLE .)

  ! SEMICOLON       [ reduce using rule 35 (variable -> DOUBLE .) ]
  ! EQUALS          [ reduce using rule 35 (variable -> DOUBLE .) ]
  ! NOT_EQUALS      [ reduce using rule 35 (variable -> DOUBLE .) ]
  ! GREATER_THAN    [ reduce using rule 35 (variable -> DOUBLE .) ]
  ! LESS_THAN       [ reduce using rule 35 (variable -> DOUBLE .) ]
  ! GREATER_THAN_OR_EQUALS [ reduce using rule 35 (variable -> DOUBLE .) ]
  ! LESS_THAN_OR_EQUALS [ reduce using rule 35 (variable -> DOUBLE .) ]
  ! RPARENTHESIS    [ reduce using rule 35 (variable -> DOUBLE .) ]
  ! COLON           [ reduce using rule 35 (variable -> DOUBLE .) ]


state 78

    (36) variable -> STRING .

    SEMICOLON       reduce using rule 36 (variable -> STRING .)
    EQUALS          reduce using rule 36 (variable -> STRING .)
    NOT_EQUALS      reduce using rule 36 (variable -> STRING .)
    GREATER_THAN    reduce using rule 36 (variable -> STRING .)
    LESS_THAN       reduce using rule 36 (variable -> STRING .)
    GREATER_THAN_OR_EQUALS reduce using rule 36 (variable -> STRING .)
    LESS_THAN_OR_EQUALS reduce using rule 36 (variable -> STRING .)
    RPARENTHESIS    reduce using rule 36 (variable -> STRING .)
    COLON           reduce using rule 36 (variable -> STRING .)


state 79

    (37) variable -> BOOL .

    SEMICOLON       reduce using rule 37 (variable -> BOOL .)
    EQUALS          reduce using rule 37 (variable -> BOOL .)
    NOT_EQUALS      reduce using rule 37 (variable -> BOOL .)
    GREATER_THAN    reduce using rule 37 (variable -> BOOL .)
    LESS_THAN       reduce using rule 37 (variable -> BOOL .)
    GREATER_THAN_OR_EQUALS reduce using rule 37 (variable -> BOOL .)
    LESS_THAN_OR_EQUALS reduce using rule 37 (variable -> BOOL .)
    RPARENTHESIS    reduce using rule 37 (variable -> BOOL .)
    COLON           reduce using rule 37 (variable -> BOOL .)


state 80

    (38) variable -> NULL .

    SEMICOLON       reduce using rule 38 (variable -> NULL .)
    EQUALS          reduce using rule 38 (variable -> NULL .)
    NOT_EQUALS      reduce using rule 38 (variable -> NULL .)
    GREATER_THAN    reduce using rule 38 (variable -> NULL .)
    LESS_THAN       reduce using rule 38 (variable -> NULL .)
    GREATER_THAN_OR_EQUALS reduce using rule 38 (variable -> NULL .)
    LESS_THAN_OR_EQUALS reduce using rule 38 (variable -> NULL .)
    RPARENTHESIS    reduce using rule 38 (variable -> NULL .)
    COLON           reduce using rule 38 (variable -> NULL .)


state 81

    (40) variable -> expression .
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    SEMICOLON       reduce using rule 40 (variable -> expression .)
    EQUALS          reduce using rule 40 (variable -> expression .)
    NOT_EQUALS      reduce using rule 40 (variable -> expression .)
    GREATER_THAN    reduce using rule 40 (variable -> expression .)
    LESS_THAN       reduce using rule 40 (variable -> expression .)
    GREATER_THAN_OR_EQUALS reduce using rule 40 (variable -> expression .)
    LESS_THAN_OR_EQUALS reduce using rule 40 (variable -> expression .)
    RPARENTHESIS    reduce using rule 40 (variable -> expression .)
    COLON           reduce using rule 40 (variable -> expression .)
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51


state 82

    (59) if -> IF LPARENTHESIS booleanExpression . RPARENTHESIS LBRACE statements RBRACE
    (60) if -> IF LPARENTHESIS booleanExpression . RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE

    RPARENTHESIS    shift and go to state 99


state 83

    (53) booleanExpression -> variable . EQUALS variable
    (54) booleanExpression -> variable . NOT_EQUALS variable
    (55) booleanExpression -> variable . GREATER_THAN variable
    (56) booleanExpression -> variable . LESS_THAN variable
    (57) booleanExpression -> variable . GREATER_THAN_OR_EQUALS variable
    (58) booleanExpression -> variable . LESS_THAN_OR_EQUALS variable

    EQUALS          shift and go to state 100
    NOT_EQUALS      shift and go to state 101
    GREATER_THAN    shift and go to state 102
    LESS_THAN       shift and go to state 103
    GREATER_THAN_OR_EQUALS shift and go to state 104
    LESS_THAN_OR_EQUALS shift and go to state 105


state 84

    (61) while -> WHILE LPARENTHESIS booleanExpression . RPARENTHESIS LBRACE statements RBRACE

    RPARENTHESIS    shift and go to state 106


state 85

    (62) for -> FOR LPARENTHESIS assignation . booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (53) booleanExpression -> . variable EQUALS variable
    (54) booleanExpression -> . variable NOT_EQUALS variable
    (55) booleanExpression -> . variable GREATER_THAN variable
    (56) booleanExpression -> . variable LESS_THAN variable
    (57) booleanExpression -> . variable GREATER_THAN_OR_EQUALS variable
    (58) booleanExpression -> . variable LESS_THAN_OR_EQUALS variable
    (34) variable -> . INT
    (35) variable -> . DOUBLE
    (36) variable -> . STRING
    (37) variable -> . BOOL
    (38) variable -> . NULL
    (39) variable -> . ID
    (40) variable -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 79
    NULL            shift and go to state 80
    ID              shift and go to state 73

    booleanExpression              shift and go to state 107
    variable                       shift and go to state 83
    expression                     shift and go to state 81
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 86

    (23) assignation -> varType . ID ASSIGN_OPERATOR variable SEMICOLON

    ID              shift and go to state 108


state 87

    (64) print -> PRINT LPARENTHESIS expression . RPARENTHESIS SEMICOLON
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    RPARENTHESIS    shift and go to state 109
    PLUS            shift and go to state 50
    MINUS           shift and go to state 51


state 88

    (66) class_def -> CLASS ID LBRACE . class_members RBRACE
    (67) class_members -> . class_members class_member
    (68) class_members -> . class_member
    (69) class_member -> . varType ID SEMICOLON
    (70) class_member -> . function
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE

    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45

    class_members                  shift and go to state 110
    class_member                   shift and go to state 111
    varType                        shift and go to state 112
    function                       shift and go to state 113

state 89

    (72) enum -> ENUM ID LBRACE . enum_values RBRACE
    (73) enum_values -> . enum_values COMMA ID
    (74) enum_values -> . ID

    ID              shift and go to state 114

    enum_values                    shift and go to state 115

state 90

    (75) try -> TRY LBRACE statements . RBRACE FINALLY LBRACE statements RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 116
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! RBRACE          [ reduce using rule 88 (empty -> .) ]
  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    statement                      shift and go to state 48
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 91

    (76) switch -> SWITCH LPARENTHESIS variable . RPARENTHESIS LBRACE cases default_case RBRACE

    RPARENTHESIS    shift and go to state 117


state 92

    (23) assignation -> varType ID ASSIGN_OPERATOR variable . SEMICOLON

    SEMICOLON       shift and go to state 118


state 93

    (84) parameter -> varType . ID

    ID              shift and go to state 119


state 94

    (71) function -> varType ID LPARENTHESIS parameters . RPARENTHESIS LBRACE statements RBRACE
    (81) parameters -> parameters . COMMA parameter

    RPARENTHESIS    shift and go to state 120
    COMMA           shift and go to state 121


state 95

    (82) parameters -> parameter .

    RPARENTHESIS    reduce using rule 82 (parameters -> parameter .)
    COMMA           reduce using rule 82 (parameters -> parameter .)


state 96

    (83) parameters -> empty .

    RPARENTHESIS    reduce using rule 83 (parameters -> empty .)
    COMMA           reduce using rule 83 (parameters -> empty .)


state 97

    (24) assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .

    ID              reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    IF              reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    WHILE           reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    FOR             reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    PRINT           reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    CLASS           reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    ENUM            reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    TRY             reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    SWITCH          reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    INT_TYPE        reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    STRING_TYPE     reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    NUM_TYPE        reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    BOOL_TYPE       reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    LIST_TYPE       reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    MAP_TYPE        reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    SET_TYPE        reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    VAR             reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    CONST           reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    FINAL           reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    VOID            reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    INT             reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    DOUBLE          reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    $end            reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    RBRACE          reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)
    BREAK           reduce using rule 24 (assignation_no_type -> ID ASSIGN_OPERATOR variable SEMICOLON .)


state 98

    (65) input -> ID ASSIGN_OPERATOR STDIN DOT . READ LPARENTHESIS RPARENTHESIS SEMICOLON

    READ            shift and go to state 122


state 99

    (59) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS . LBRACE statements RBRACE
    (60) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS . LBRACE statements RBRACE ELSE LBRACE statements RBRACE

    LBRACE          shift and go to state 123


state 100

    (53) booleanExpression -> variable EQUALS . variable
    (34) variable -> . INT
    (35) variable -> . DOUBLE
    (36) variable -> . STRING
    (37) variable -> . BOOL
    (38) variable -> . NULL
    (39) variable -> . ID
    (40) variable -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 79
    NULL            shift and go to state 80
    ID              shift and go to state 73

    variable                       shift and go to state 124
    expression                     shift and go to state 81
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 101

    (54) booleanExpression -> variable NOT_EQUALS . variable
    (34) variable -> . INT
    (35) variable -> . DOUBLE
    (36) variable -> . STRING
    (37) variable -> . BOOL
    (38) variable -> . NULL
    (39) variable -> . ID
    (40) variable -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 79
    NULL            shift and go to state 80
    ID              shift and go to state 73

    variable                       shift and go to state 125
    expression                     shift and go to state 81
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 102

    (55) booleanExpression -> variable GREATER_THAN . variable
    (34) variable -> . INT
    (35) variable -> . DOUBLE
    (36) variable -> . STRING
    (37) variable -> . BOOL
    (38) variable -> . NULL
    (39) variable -> . ID
    (40) variable -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 79
    NULL            shift and go to state 80
    ID              shift and go to state 73

    variable                       shift and go to state 126
    expression                     shift and go to state 81
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 103

    (56) booleanExpression -> variable LESS_THAN . variable
    (34) variable -> . INT
    (35) variable -> . DOUBLE
    (36) variable -> . STRING
    (37) variable -> . BOOL
    (38) variable -> . NULL
    (39) variable -> . ID
    (40) variable -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 79
    NULL            shift and go to state 80
    ID              shift and go to state 73

    variable                       shift and go to state 127
    expression                     shift and go to state 81
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 104

    (57) booleanExpression -> variable GREATER_THAN_OR_EQUALS . variable
    (34) variable -> . INT
    (35) variable -> . DOUBLE
    (36) variable -> . STRING
    (37) variable -> . BOOL
    (38) variable -> . NULL
    (39) variable -> . ID
    (40) variable -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 79
    NULL            shift and go to state 80
    ID              shift and go to state 73

    variable                       shift and go to state 128
    expression                     shift and go to state 81
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 105

    (58) booleanExpression -> variable LESS_THAN_OR_EQUALS . variable
    (34) variable -> . INT
    (35) variable -> . DOUBLE
    (36) variable -> . STRING
    (37) variable -> . BOOL
    (38) variable -> . NULL
    (39) variable -> . ID
    (40) variable -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 79
    NULL            shift and go to state 80
    ID              shift and go to state 73

    variable                       shift and go to state 129
    expression                     shift and go to state 81
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 106

    (61) while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS . LBRACE statements RBRACE

    LBRACE          shift and go to state 130


state 107

    (62) for -> FOR LPARENTHESIS assignation booleanExpression . SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE

    SEMICOLON       shift and go to state 131


state 108

    (23) assignation -> varType ID . ASSIGN_OPERATOR variable SEMICOLON

    ASSIGN_OPERATOR shift and go to state 71


state 109

    (64) print -> PRINT LPARENTHESIS expression RPARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 132


state 110

    (66) class_def -> CLASS ID LBRACE class_members . RBRACE
    (67) class_members -> class_members . class_member
    (69) class_member -> . varType ID SEMICOLON
    (70) class_member -> . function
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE

    RBRACE          shift and go to state 133
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45

    class_member                   shift and go to state 134
    varType                        shift and go to state 112
    function                       shift and go to state 113

state 111

    (68) class_members -> class_member .

    RBRACE          reduce using rule 68 (class_members -> class_member .)
    INT_TYPE        reduce using rule 68 (class_members -> class_member .)
    STRING_TYPE     reduce using rule 68 (class_members -> class_member .)
    NUM_TYPE        reduce using rule 68 (class_members -> class_member .)
    DOUBLE_TYPE     reduce using rule 68 (class_members -> class_member .)
    BOOL_TYPE       reduce using rule 68 (class_members -> class_member .)
    LIST_TYPE       reduce using rule 68 (class_members -> class_member .)
    MAP_TYPE        reduce using rule 68 (class_members -> class_member .)
    SET_TYPE        reduce using rule 68 (class_members -> class_member .)
    VAR             reduce using rule 68 (class_members -> class_member .)
    CONST           reduce using rule 68 (class_members -> class_member .)
    FINAL           reduce using rule 68 (class_members -> class_member .)
    VOID            reduce using rule 68 (class_members -> class_member .)


state 112

    (69) class_member -> varType . ID SEMICOLON
    (71) function -> varType . ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE

    ID              shift and go to state 135


state 113

    (70) class_member -> function .

    RBRACE          reduce using rule 70 (class_member -> function .)
    INT_TYPE        reduce using rule 70 (class_member -> function .)
    STRING_TYPE     reduce using rule 70 (class_member -> function .)
    NUM_TYPE        reduce using rule 70 (class_member -> function .)
    DOUBLE_TYPE     reduce using rule 70 (class_member -> function .)
    BOOL_TYPE       reduce using rule 70 (class_member -> function .)
    LIST_TYPE       reduce using rule 70 (class_member -> function .)
    MAP_TYPE        reduce using rule 70 (class_member -> function .)
    SET_TYPE        reduce using rule 70 (class_member -> function .)
    VAR             reduce using rule 70 (class_member -> function .)
    CONST           reduce using rule 70 (class_member -> function .)
    FINAL           reduce using rule 70 (class_member -> function .)
    VOID            reduce using rule 70 (class_member -> function .)


state 114

    (74) enum_values -> ID .

    RBRACE          reduce using rule 74 (enum_values -> ID .)
    COMMA           reduce using rule 74 (enum_values -> ID .)


state 115

    (72) enum -> ENUM ID LBRACE enum_values . RBRACE
    (73) enum_values -> enum_values . COMMA ID

    RBRACE          shift and go to state 136
    COMMA           shift and go to state 137


state 116

    (75) try -> TRY LBRACE statements RBRACE . FINALLY LBRACE statements RBRACE

    FINALLY         shift and go to state 138


state 117

    (76) switch -> SWITCH LPARENTHESIS variable RPARENTHESIS . LBRACE cases default_case RBRACE

    LBRACE          shift and go to state 139


state 118

    (23) assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .

    ID              reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    IF              reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    WHILE           reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    FOR             reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    PRINT           reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    CLASS           reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    ENUM            reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    TRY             reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    SWITCH          reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    INT_TYPE        reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    STRING_TYPE     reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    NUM_TYPE        reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    BOOL_TYPE       reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    LIST_TYPE       reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    MAP_TYPE        reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    SET_TYPE        reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    VAR             reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    CONST           reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    FINAL           reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    VOID            reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    INT             reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    DOUBLE          reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    $end            reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    STRING          reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    BOOL            reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    NULL            reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    RBRACE          reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)
    BREAK           reduce using rule 23 (assignation -> varType ID ASSIGN_OPERATOR variable SEMICOLON .)


state 119

    (84) parameter -> varType ID .

    RPARENTHESIS    reduce using rule 84 (parameter -> varType ID .)
    COMMA           reduce using rule 84 (parameter -> varType ID .)


state 120

    (71) function -> varType ID LPARENTHESIS parameters RPARENTHESIS . LBRACE statements RBRACE

    LBRACE          shift and go to state 140


state 121

    (81) parameters -> parameters COMMA . parameter
    (84) parameter -> . varType ID
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID

    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45

    parameter                      shift and go to state 141
    varType                        shift and go to state 93

state 122

    (65) input -> ID ASSIGN_OPERATOR STDIN DOT READ . LPARENTHESIS RPARENTHESIS SEMICOLON

    LPARENTHESIS    shift and go to state 142


state 123

    (59) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE . statements RBRACE
    (60) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE . statements RBRACE ELSE LBRACE statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    RBRACE          reduce using rule 88 (empty -> .)
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    statements                     shift and go to state 143
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 124

    (53) booleanExpression -> variable EQUALS variable .

    RPARENTHESIS    reduce using rule 53 (booleanExpression -> variable EQUALS variable .)
    SEMICOLON       reduce using rule 53 (booleanExpression -> variable EQUALS variable .)


state 125

    (54) booleanExpression -> variable NOT_EQUALS variable .

    RPARENTHESIS    reduce using rule 54 (booleanExpression -> variable NOT_EQUALS variable .)
    SEMICOLON       reduce using rule 54 (booleanExpression -> variable NOT_EQUALS variable .)


state 126

    (55) booleanExpression -> variable GREATER_THAN variable .

    RPARENTHESIS    reduce using rule 55 (booleanExpression -> variable GREATER_THAN variable .)
    SEMICOLON       reduce using rule 55 (booleanExpression -> variable GREATER_THAN variable .)


state 127

    (56) booleanExpression -> variable LESS_THAN variable .

    RPARENTHESIS    reduce using rule 56 (booleanExpression -> variable LESS_THAN variable .)
    SEMICOLON       reduce using rule 56 (booleanExpression -> variable LESS_THAN variable .)


state 128

    (57) booleanExpression -> variable GREATER_THAN_OR_EQUALS variable .

    RPARENTHESIS    reduce using rule 57 (booleanExpression -> variable GREATER_THAN_OR_EQUALS variable .)
    SEMICOLON       reduce using rule 57 (booleanExpression -> variable GREATER_THAN_OR_EQUALS variable .)


state 129

    (58) booleanExpression -> variable LESS_THAN_OR_EQUALS variable .

    RPARENTHESIS    reduce using rule 58 (booleanExpression -> variable LESS_THAN_OR_EQUALS variable .)
    SEMICOLON       reduce using rule 58 (booleanExpression -> variable LESS_THAN_OR_EQUALS variable .)


state 130

    (61) while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    RBRACE          reduce using rule 88 (empty -> .)
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    statements                     shift and go to state 144
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 131

    (62) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON . increment RPARENTHESIS LBRACE statements RBRACE
    (63) increment -> . ID INCREMENT

    ID              shift and go to state 146

    increment                      shift and go to state 145

state 132

    (64) print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .

    ID              reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    IF              reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    FOR             reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    PRINT           reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    CLASS           reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    ENUM            reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    TRY             reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    SWITCH          reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    INT_TYPE        reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    STRING_TYPE     reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    NUM_TYPE        reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    BOOL_TYPE       reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    LIST_TYPE       reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    MAP_TYPE        reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    SET_TYPE        reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    VAR             reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    CONST           reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    FINAL           reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    VOID            reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    INT             reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    DOUBLE          reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    $end            reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    RBRACE          reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)
    BREAK           reduce using rule 64 (print -> PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON .)


state 133

    (66) class_def -> CLASS ID LBRACE class_members RBRACE .

    ID              reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    IF              reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    WHILE           reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    FOR             reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    PRINT           reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    CLASS           reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    ENUM            reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    TRY             reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    SWITCH          reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    INT_TYPE        reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    STRING_TYPE     reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    NUM_TYPE        reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    DOUBLE_TYPE     reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    BOOL_TYPE       reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    LIST_TYPE       reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    MAP_TYPE        reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    SET_TYPE        reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    VAR             reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    CONST           reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    FINAL           reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    VOID            reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    INT             reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    DOUBLE          reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    $end            reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    RBRACE          reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)
    BREAK           reduce using rule 66 (class_def -> CLASS ID LBRACE class_members RBRACE .)


state 134

    (67) class_members -> class_members class_member .

    RBRACE          reduce using rule 67 (class_members -> class_members class_member .)
    INT_TYPE        reduce using rule 67 (class_members -> class_members class_member .)
    STRING_TYPE     reduce using rule 67 (class_members -> class_members class_member .)
    NUM_TYPE        reduce using rule 67 (class_members -> class_members class_member .)
    DOUBLE_TYPE     reduce using rule 67 (class_members -> class_members class_member .)
    BOOL_TYPE       reduce using rule 67 (class_members -> class_members class_member .)
    LIST_TYPE       reduce using rule 67 (class_members -> class_members class_member .)
    MAP_TYPE        reduce using rule 67 (class_members -> class_members class_member .)
    SET_TYPE        reduce using rule 67 (class_members -> class_members class_member .)
    VAR             reduce using rule 67 (class_members -> class_members class_member .)
    CONST           reduce using rule 67 (class_members -> class_members class_member .)
    FINAL           reduce using rule 67 (class_members -> class_members class_member .)
    VOID            reduce using rule 67 (class_members -> class_members class_member .)


state 135

    (69) class_member -> varType ID . SEMICOLON
    (71) function -> varType ID . LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE

    SEMICOLON       shift and go to state 147
    LPARENTHESIS    shift and go to state 72


state 136

    (72) enum -> ENUM ID LBRACE enum_values RBRACE .

    ID              reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    IF              reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    WHILE           reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    FOR             reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    PRINT           reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    CLASS           reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    ENUM            reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    TRY             reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    SWITCH          reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    INT_TYPE        reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    STRING_TYPE     reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    NUM_TYPE        reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    DOUBLE_TYPE     reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    BOOL_TYPE       reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    LIST_TYPE       reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    MAP_TYPE        reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    SET_TYPE        reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    VAR             reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    CONST           reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    FINAL           reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    VOID            reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    INT             reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    DOUBLE          reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    $end            reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    RBRACE          reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)
    BREAK           reduce using rule 72 (enum -> ENUM ID LBRACE enum_values RBRACE .)


state 137

    (73) enum_values -> enum_values COMMA . ID

    ID              shift and go to state 148


state 138

    (75) try -> TRY LBRACE statements RBRACE FINALLY . LBRACE statements RBRACE

    LBRACE          shift and go to state 149


state 139

    (76) switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE . cases default_case RBRACE
    (77) cases -> . cases case
    (78) cases -> . case
    (79) case -> . CASE variable COLON statements BREAK SEMICOLON

    CASE            shift and go to state 152

    cases                          shift and go to state 150
    case                           shift and go to state 151

state 140

    (71) function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    RBRACE          reduce using rule 88 (empty -> .)
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    varType                        shift and go to state 23
    statements                     shift and go to state 153
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 141

    (81) parameters -> parameters COMMA parameter .

    RPARENTHESIS    reduce using rule 81 (parameters -> parameters COMMA parameter .)
    COMMA           reduce using rule 81 (parameters -> parameters COMMA parameter .)


state 142

    (65) input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS . RPARENTHESIS SEMICOLON

    RPARENTHESIS    shift and go to state 154


state 143

    (59) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements . RBRACE
    (60) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements . RBRACE ELSE LBRACE statements RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 155
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! RBRACE          [ reduce using rule 88 (empty -> .) ]
  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    statement                      shift and go to state 48
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 144

    (61) while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 156
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! RBRACE          [ reduce using rule 88 (empty -> .) ]
  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    statement                      shift and go to state 48
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 145

    (62) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment . RPARENTHESIS LBRACE statements RBRACE

    RPARENTHESIS    shift and go to state 157


state 146

    (63) increment -> ID . INCREMENT

    INCREMENT       shift and go to state 158


state 147

    (69) class_member -> varType ID SEMICOLON .

    RBRACE          reduce using rule 69 (class_member -> varType ID SEMICOLON .)
    INT_TYPE        reduce using rule 69 (class_member -> varType ID SEMICOLON .)
    STRING_TYPE     reduce using rule 69 (class_member -> varType ID SEMICOLON .)
    NUM_TYPE        reduce using rule 69 (class_member -> varType ID SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 69 (class_member -> varType ID SEMICOLON .)
    BOOL_TYPE       reduce using rule 69 (class_member -> varType ID SEMICOLON .)
    LIST_TYPE       reduce using rule 69 (class_member -> varType ID SEMICOLON .)
    MAP_TYPE        reduce using rule 69 (class_member -> varType ID SEMICOLON .)
    SET_TYPE        reduce using rule 69 (class_member -> varType ID SEMICOLON .)
    VAR             reduce using rule 69 (class_member -> varType ID SEMICOLON .)
    CONST           reduce using rule 69 (class_member -> varType ID SEMICOLON .)
    FINAL           reduce using rule 69 (class_member -> varType ID SEMICOLON .)
    VOID            reduce using rule 69 (class_member -> varType ID SEMICOLON .)


state 148

    (73) enum_values -> enum_values COMMA ID .

    RBRACE          reduce using rule 73 (enum_values -> enum_values COMMA ID .)
    COMMA           reduce using rule 73 (enum_values -> enum_values COMMA ID .)


state 149

    (75) try -> TRY LBRACE statements RBRACE FINALLY LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    RBRACE          reduce using rule 88 (empty -> .)
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    statements                     shift and go to state 159
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 150

    (76) switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases . default_case RBRACE
    (77) cases -> cases . case
    (80) default_case -> . DEFAULT COLON statements
    (79) case -> . CASE variable COLON statements BREAK SEMICOLON

    DEFAULT         shift and go to state 162
    CASE            shift and go to state 152

    default_case                   shift and go to state 160
    case                           shift and go to state 161

state 151

    (78) cases -> case .

    DEFAULT         reduce using rule 78 (cases -> case .)
    CASE            reduce using rule 78 (cases -> case .)


state 152

    (79) case -> CASE . variable COLON statements BREAK SEMICOLON
    (34) variable -> . INT
    (35) variable -> . DOUBLE
    (36) variable -> . STRING
    (37) variable -> . BOOL
    (38) variable -> . NULL
    (39) variable -> . ID
    (40) variable -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (32) factor -> . INT
    (33) factor -> . DOUBLE

    INT             shift and go to state 76
    DOUBLE          shift and go to state 77
    STRING          shift and go to state 78
    BOOL            shift and go to state 79
    NULL            shift and go to state 80
    ID              shift and go to state 73

    variable                       shift and go to state 163
    expression                     shift and go to state 81
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 153

    (71) function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 164
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! RBRACE          [ reduce using rule 88 (empty -> .) ]
  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    varType                        shift and go to state 23
    statement                      shift and go to state 48
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    factor                         shift and go to state 33

state 154

    (65) input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS . SEMICOLON

    SEMICOLON       shift and go to state 165


state 155

    (59) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .
    (60) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE . ELSE LBRACE statements RBRACE

    ID              reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    IF              reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    WHILE           reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    FOR             reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    PRINT           reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    CLASS           reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    ENUM            reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    TRY             reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    SWITCH          reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    STRING_TYPE     reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    NUM_TYPE        reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE_TYPE     reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    LIST_TYPE       reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    MAP_TYPE        reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    SET_TYPE        reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    VAR             reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    CONST           reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    FINAL           reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    VOID            reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    INT             reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    $end            reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    RBRACE          reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    BREAK           reduce using rule 59 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    ELSE            shift and go to state 166


state 156

    (61) while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .

    ID              reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    IF              reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    WHILE           reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    FOR             reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    PRINT           reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    CLASS           reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    ENUM            reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    TRY             reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    SWITCH          reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    STRING_TYPE     reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    NUM_TYPE        reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE_TYPE     reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    LIST_TYPE       reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    MAP_TYPE        reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    SET_TYPE        reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    VAR             reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    CONST           reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    FINAL           reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    VOID            reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    INT             reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    $end            reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    RBRACE          reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)
    BREAK           reduce using rule 61 (while -> WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE .)


state 157

    (62) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS . LBRACE statements RBRACE

    LBRACE          shift and go to state 167


state 158

    (63) increment -> ID INCREMENT .

    RPARENTHESIS    reduce using rule 63 (increment -> ID INCREMENT .)


state 159

    (75) try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 168
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! RBRACE          [ reduce using rule 88 (empty -> .) ]
  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    statement                      shift and go to state 48
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 160

    (76) switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case . RBRACE

    RBRACE          shift and go to state 169


state 161

    (77) cases -> cases case .

    DEFAULT         reduce using rule 77 (cases -> cases case .)
    CASE            reduce using rule 77 (cases -> cases case .)


state 162

    (80) default_case -> DEFAULT . COLON statements

    COLON           shift and go to state 170


state 163

    (79) case -> CASE variable . COLON statements BREAK SEMICOLON

    COLON           shift and go to state 171


state 164

    (71) function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .

    ID              reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    IF              reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    WHILE           reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    FOR             reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    PRINT           reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    CLASS           reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    ENUM            reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    TRY             reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    SWITCH          reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    STRING_TYPE     reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    NUM_TYPE        reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE_TYPE     reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    LIST_TYPE       reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    MAP_TYPE        reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    SET_TYPE        reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    VAR             reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    CONST           reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    FINAL           reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    VOID            reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    INT             reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    $end            reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    RBRACE          reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)
    BREAK           reduce using rule 71 (function -> varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE .)


state 165

    (65) input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .

    ID              reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    IF              reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    WHILE           reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    FOR             reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    PRINT           reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    CLASS           reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    ENUM            reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    TRY             reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    SWITCH          reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    INT_TYPE        reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    STRING_TYPE     reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    NUM_TYPE        reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    DOUBLE_TYPE     reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    BOOL_TYPE       reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    LIST_TYPE       reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    MAP_TYPE        reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    SET_TYPE        reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    VAR             reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    CONST           reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    FINAL           reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    VOID            reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    INT             reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    DOUBLE          reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    $end            reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    RBRACE          reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)
    BREAK           reduce using rule 65 (input -> ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON .)


state 166

    (60) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE . LBRACE statements RBRACE

    LBRACE          shift and go to state 172


state 167

    (62) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    RBRACE          reduce using rule 88 (empty -> .)
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    assignation                    shift and go to state 6
    statements                     shift and go to state 173
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 168

    (75) try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .

    ID              reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    IF              reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    WHILE           reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    FOR             reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    PRINT           reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    CLASS           reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    ENUM            reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    TRY             reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    SWITCH          reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    STRING_TYPE     reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    NUM_TYPE        reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    DOUBLE_TYPE     reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    LIST_TYPE       reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    MAP_TYPE        reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    SET_TYPE        reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    VAR             reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    CONST           reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    FINAL           reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    VOID            reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    INT             reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    $end            reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    RBRACE          reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)
    BREAK           reduce using rule 75 (try -> TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE .)


state 169

    (76) switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .

    ID              reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    IF              reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    WHILE           reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    FOR             reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    PRINT           reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    CLASS           reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    ENUM            reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    TRY             reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    SWITCH          reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    INT_TYPE        reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    STRING_TYPE     reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    NUM_TYPE        reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    DOUBLE_TYPE     reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    BOOL_TYPE       reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    LIST_TYPE       reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    MAP_TYPE        reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    SET_TYPE        reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    VAR             reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    CONST           reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    FINAL           reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    VOID            reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    INT             reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    DOUBLE          reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    $end            reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    RBRACE          reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)
    BREAK           reduce using rule 76 (switch -> SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE .)


state 170

    (80) default_case -> DEFAULT COLON . statements
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    RBRACE          reduce using rule 88 (empty -> .)
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    statements                     shift and go to state 174
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 171

    (79) case -> CASE variable COLON . statements BREAK SEMICOLON
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    BREAK           reduce using rule 88 (empty -> .)
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    statements                     shift and go to state 175
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 172

    (60) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE . statements RBRACE
    (2) statements -> . statements statement
    (3) statements -> . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    RBRACE          reduce using rule 88 (empty -> .)
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    statements                     shift and go to state 176
    statement                      shift and go to state 3
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 173

    (62) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 177
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! RBRACE          [ reduce using rule 88 (empty -> .) ]
  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    assignation                    shift and go to state 6
    statement                      shift and go to state 48
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 174

    (80) default_case -> DEFAULT COLON statements .
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! reduce/reduce conflict for RBRACE resolved using rule 80 (default_case -> DEFAULT COLON statements .)
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          reduce using rule 80 (default_case -> DEFAULT COLON statements .)
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]
  ! RBRACE          [ reduce using rule 88 (empty -> .) ]

    statement                      shift and go to state 48
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 175

    (79) case -> CASE variable COLON statements . BREAK SEMICOLON
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    BREAK           shift and go to state 178
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! BREAK           [ reduce using rule 88 (empty -> .) ]
  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    statement                      shift and go to state 48
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 176

    (60) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements . RBRACE
    (2) statements -> statements . statement
    (4) statement -> . expression SEMICOLON
    (5) statement -> . declaration
    (6) statement -> . assignation
    (7) statement -> . assignation_no_type
    (8) statement -> . function
    (9) statement -> . if
    (10) statement -> . while
    (11) statement -> . for
    (12) statement -> . print
    (13) statement -> . input
    (14) statement -> . class_def
    (15) statement -> . enum
    (16) statement -> . try
    (17) statement -> . switch
    (18) statement -> . list
    (19) statement -> . set
    (20) statement -> . map
    (21) statement -> . empty
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (22) declaration -> . varType ID SEMICOLON
    (23) assignation -> . varType ID ASSIGN_OPERATOR variable SEMICOLON
    (24) assignation_no_type -> . ID ASSIGN_OPERATOR variable SEMICOLON
    (71) function -> . varType ID LPARENTHESIS parameters RPARENTHESIS LBRACE statements RBRACE
    (59) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (60) if -> . IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE
    (61) while -> . WHILE LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE
    (62) for -> . FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE
    (64) print -> . PRINT LPARENTHESIS expression RPARENTHESIS SEMICOLON
    (65) input -> . ID ASSIGN_OPERATOR STDIN DOT READ LPARENTHESIS RPARENTHESIS SEMICOLON
    (66) class_def -> . CLASS ID LBRACE class_members RBRACE
    (72) enum -> . ENUM ID LBRACE enum_values RBRACE
    (75) try -> . TRY LBRACE statements RBRACE FINALLY LBRACE statements RBRACE
    (76) switch -> . SWITCH LPARENTHESIS variable RPARENTHESIS LBRACE cases default_case RBRACE
    (85) list -> . empty
    (86) set -> . empty
    (87) map -> . empty
    (88) empty -> .
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . term MODULE factor
    (31) term -> . factor
    (41) varType -> . INT_TYPE
    (42) varType -> . STRING_TYPE
    (43) varType -> . NUM_TYPE
    (44) varType -> . DOUBLE_TYPE
    (45) varType -> . BOOL_TYPE
    (46) varType -> . LIST_TYPE
    (47) varType -> . MAP_TYPE
    (48) varType -> . SET_TYPE
    (49) varType -> . VAR
    (50) varType -> . CONST
    (51) varType -> . FINAL
    (52) varType -> . VOID
    (32) factor -> . INT
    (33) factor -> . DOUBLE

  ! shift/reduce conflict for RBRACE resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for PRINT resolved as shift
  ! shift/reduce conflict for CLASS resolved as shift
  ! shift/reduce conflict for ENUM resolved as shift
  ! shift/reduce conflict for TRY resolved as shift
  ! shift/reduce conflict for SWITCH resolved as shift
  ! shift/reduce conflict for INT_TYPE resolved as shift
  ! shift/reduce conflict for STRING_TYPE resolved as shift
  ! shift/reduce conflict for NUM_TYPE resolved as shift
  ! shift/reduce conflict for DOUBLE_TYPE resolved as shift
  ! shift/reduce conflict for BOOL_TYPE resolved as shift
  ! shift/reduce conflict for LIST_TYPE resolved as shift
  ! shift/reduce conflict for MAP_TYPE resolved as shift
  ! shift/reduce conflict for SET_TYPE resolved as shift
  ! shift/reduce conflict for VAR resolved as shift
  ! shift/reduce conflict for CONST resolved as shift
  ! shift/reduce conflict for FINAL resolved as shift
  ! shift/reduce conflict for VOID resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for DOUBLE resolved as shift
    RBRACE          shift and go to state 179
    ID              shift and go to state 24
    IF              shift and go to state 25
    WHILE           shift and go to state 26
    FOR             shift and go to state 27
    PRINT           shift and go to state 28
    CLASS           shift and go to state 29
    ENUM            shift and go to state 30
    TRY             shift and go to state 31
    SWITCH          shift and go to state 32
    INT_TYPE        shift and go to state 34
    STRING_TYPE     shift and go to state 35
    NUM_TYPE        shift and go to state 36
    DOUBLE_TYPE     shift and go to state 37
    BOOL_TYPE       shift and go to state 38
    LIST_TYPE       shift and go to state 39
    MAP_TYPE        shift and go to state 40
    SET_TYPE        shift and go to state 41
    VAR             shift and go to state 42
    CONST           shift and go to state 43
    FINAL           shift and go to state 44
    VOID            shift and go to state 45
    INT             shift and go to state 46
    DOUBLE          shift and go to state 47

  ! RBRACE          [ reduce using rule 88 (empty -> .) ]
  ! ID              [ reduce using rule 88 (empty -> .) ]
  ! IF              [ reduce using rule 88 (empty -> .) ]
  ! WHILE           [ reduce using rule 88 (empty -> .) ]
  ! FOR             [ reduce using rule 88 (empty -> .) ]
  ! PRINT           [ reduce using rule 88 (empty -> .) ]
  ! CLASS           [ reduce using rule 88 (empty -> .) ]
  ! ENUM            [ reduce using rule 88 (empty -> .) ]
  ! TRY             [ reduce using rule 88 (empty -> .) ]
  ! SWITCH          [ reduce using rule 88 (empty -> .) ]
  ! INT_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! STRING_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! NUM_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE_TYPE     [ reduce using rule 88 (empty -> .) ]
  ! BOOL_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! LIST_TYPE       [ reduce using rule 88 (empty -> .) ]
  ! MAP_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! SET_TYPE        [ reduce using rule 88 (empty -> .) ]
  ! VAR             [ reduce using rule 88 (empty -> .) ]
  ! CONST           [ reduce using rule 88 (empty -> .) ]
  ! FINAL           [ reduce using rule 88 (empty -> .) ]
  ! VOID            [ reduce using rule 88 (empty -> .) ]
  ! INT             [ reduce using rule 88 (empty -> .) ]
  ! DOUBLE          [ reduce using rule 88 (empty -> .) ]

    statement                      shift and go to state 48
    expression                     shift and go to state 4
    declaration                    shift and go to state 5
    assignation                    shift and go to state 6
    assignation_no_type            shift and go to state 7
    function                       shift and go to state 8
    if                             shift and go to state 9
    while                          shift and go to state 10
    for                            shift and go to state 11
    print                          shift and go to state 12
    input                          shift and go to state 13
    class_def                      shift and go to state 14
    enum                           shift and go to state 15
    try                            shift and go to state 16
    switch                         shift and go to state 17
    list                           shift and go to state 18
    set                            shift and go to state 19
    map                            shift and go to state 20
    empty                          shift and go to state 21
    term                           shift and go to state 22
    varType                        shift and go to state 23
    factor                         shift and go to state 33

state 177

    (62) for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .

    ID              reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    IF              reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    WHILE           reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    FOR             reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    PRINT           reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    CLASS           reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    ENUM            reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    TRY             reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    SWITCH          reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    STRING_TYPE     reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    NUM_TYPE        reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE_TYPE     reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    LIST_TYPE       reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    MAP_TYPE        reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    SET_TYPE        reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    VAR             reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    CONST           reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    FINAL           reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    VOID            reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    INT             reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    $end            reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    RBRACE          reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)
    BREAK           reduce using rule 62 (for -> FOR LPARENTHESIS assignation booleanExpression SEMICOLON increment RPARENTHESIS LBRACE statements RBRACE .)


state 178

    (79) case -> CASE variable COLON statements BREAK . SEMICOLON

    SEMICOLON       shift and go to state 180


state 179

    (60) if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .

    ID              reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    IF              reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    WHILE           reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    FOR             reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    PRINT           reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    CLASS           reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    ENUM            reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    TRY             reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    SWITCH          reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    INT_TYPE        reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    STRING_TYPE     reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    NUM_TYPE        reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    DOUBLE_TYPE     reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    BOOL_TYPE       reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    LIST_TYPE       reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    MAP_TYPE        reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    SET_TYPE        reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    VAR             reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    CONST           reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    FINAL           reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    VOID            reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    INT             reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    DOUBLE          reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    $end            reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    RBRACE          reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)
    BREAK           reduce using rule 60 (if -> IF LPARENTHESIS booleanExpression RPARENTHESIS LBRACE statements RBRACE ELSE LBRACE statements RBRACE .)


state 180

    (79) case -> CASE variable COLON statements BREAK SEMICOLON .

    DEFAULT         reduce using rule 79 (case -> CASE variable COLON statements BREAK SEMICOLON .)
    CASE            reduce using rule 79 (case -> CASE variable COLON statements BREAK SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 0 resolved as shift
WARNING: shift/reduce conflict for IF in state 0 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 0 resolved as shift
WARNING: shift/reduce conflict for FOR in state 0 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 0 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 0 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 0 resolved as shift
WARNING: shift/reduce conflict for TRY in state 0 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 0 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 0 resolved as shift
WARNING: shift/reduce conflict for VAR in state 0 resolved as shift
WARNING: shift/reduce conflict for CONST in state 0 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 0 resolved as shift
WARNING: shift/reduce conflict for VOID in state 0 resolved as shift
WARNING: shift/reduce conflict for INT in state 0 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 0 resolved as shift
WARNING: shift/reduce conflict for ID in state 2 resolved as shift
WARNING: shift/reduce conflict for IF in state 2 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 2 resolved as shift
WARNING: shift/reduce conflict for FOR in state 2 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 2 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 2 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 2 resolved as shift
WARNING: shift/reduce conflict for TRY in state 2 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 2 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 2 resolved as shift
WARNING: shift/reduce conflict for VAR in state 2 resolved as shift
WARNING: shift/reduce conflict for CONST in state 2 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 2 resolved as shift
WARNING: shift/reduce conflict for VOID in state 2 resolved as shift
WARNING: shift/reduce conflict for INT in state 2 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 2 resolved as shift
WARNING: shift/reduce conflict for ID in state 63 resolved as shift
WARNING: shift/reduce conflict for IF in state 63 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 63 resolved as shift
WARNING: shift/reduce conflict for FOR in state 63 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 63 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 63 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 63 resolved as shift
WARNING: shift/reduce conflict for TRY in state 63 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 63 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 63 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 63 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 63 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 63 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 63 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 63 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 63 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 63 resolved as shift
WARNING: shift/reduce conflict for VAR in state 63 resolved as shift
WARNING: shift/reduce conflict for CONST in state 63 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 63 resolved as shift
WARNING: shift/reduce conflict for VOID in state 63 resolved as shift
WARNING: shift/reduce conflict for INT in state 63 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 63 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 90 resolved as shift
WARNING: shift/reduce conflict for ID in state 90 resolved as shift
WARNING: shift/reduce conflict for IF in state 90 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 90 resolved as shift
WARNING: shift/reduce conflict for FOR in state 90 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 90 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 90 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 90 resolved as shift
WARNING: shift/reduce conflict for TRY in state 90 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 90 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 90 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 90 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 90 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 90 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 90 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 90 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 90 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 90 resolved as shift
WARNING: shift/reduce conflict for VAR in state 90 resolved as shift
WARNING: shift/reduce conflict for CONST in state 90 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 90 resolved as shift
WARNING: shift/reduce conflict for VOID in state 90 resolved as shift
WARNING: shift/reduce conflict for INT in state 90 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 90 resolved as shift
WARNING: shift/reduce conflict for ID in state 123 resolved as shift
WARNING: shift/reduce conflict for IF in state 123 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 123 resolved as shift
WARNING: shift/reduce conflict for FOR in state 123 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 123 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 123 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 123 resolved as shift
WARNING: shift/reduce conflict for TRY in state 123 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 123 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 123 resolved as shift
WARNING: shift/reduce conflict for VAR in state 123 resolved as shift
WARNING: shift/reduce conflict for CONST in state 123 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 123 resolved as shift
WARNING: shift/reduce conflict for VOID in state 123 resolved as shift
WARNING: shift/reduce conflict for INT in state 123 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 123 resolved as shift
WARNING: shift/reduce conflict for ID in state 130 resolved as shift
WARNING: shift/reduce conflict for IF in state 130 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 130 resolved as shift
WARNING: shift/reduce conflict for FOR in state 130 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 130 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 130 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 130 resolved as shift
WARNING: shift/reduce conflict for TRY in state 130 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 130 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 130 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 130 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 130 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 130 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 130 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 130 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 130 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 130 resolved as shift
WARNING: shift/reduce conflict for VAR in state 130 resolved as shift
WARNING: shift/reduce conflict for CONST in state 130 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 130 resolved as shift
WARNING: shift/reduce conflict for VOID in state 130 resolved as shift
WARNING: shift/reduce conflict for INT in state 130 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 130 resolved as shift
WARNING: shift/reduce conflict for ID in state 140 resolved as shift
WARNING: shift/reduce conflict for IF in state 140 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 140 resolved as shift
WARNING: shift/reduce conflict for FOR in state 140 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 140 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 140 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 140 resolved as shift
WARNING: shift/reduce conflict for TRY in state 140 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 140 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 140 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 140 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 140 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 140 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 140 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 140 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 140 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 140 resolved as shift
WARNING: shift/reduce conflict for VAR in state 140 resolved as shift
WARNING: shift/reduce conflict for CONST in state 140 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 140 resolved as shift
WARNING: shift/reduce conflict for VOID in state 140 resolved as shift
WARNING: shift/reduce conflict for INT in state 140 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 140 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 143 resolved as shift
WARNING: shift/reduce conflict for ID in state 143 resolved as shift
WARNING: shift/reduce conflict for IF in state 143 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 143 resolved as shift
WARNING: shift/reduce conflict for FOR in state 143 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 143 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 143 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 143 resolved as shift
WARNING: shift/reduce conflict for TRY in state 143 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 143 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 143 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 143 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 143 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 143 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 143 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 143 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 143 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 143 resolved as shift
WARNING: shift/reduce conflict for VAR in state 143 resolved as shift
WARNING: shift/reduce conflict for CONST in state 143 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 143 resolved as shift
WARNING: shift/reduce conflict for VOID in state 143 resolved as shift
WARNING: shift/reduce conflict for INT in state 143 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 143 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 144 resolved as shift
WARNING: shift/reduce conflict for ID in state 144 resolved as shift
WARNING: shift/reduce conflict for IF in state 144 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 144 resolved as shift
WARNING: shift/reduce conflict for FOR in state 144 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 144 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 144 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 144 resolved as shift
WARNING: shift/reduce conflict for TRY in state 144 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 144 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 144 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 144 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 144 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 144 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 144 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 144 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 144 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 144 resolved as shift
WARNING: shift/reduce conflict for VAR in state 144 resolved as shift
WARNING: shift/reduce conflict for CONST in state 144 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 144 resolved as shift
WARNING: shift/reduce conflict for VOID in state 144 resolved as shift
WARNING: shift/reduce conflict for INT in state 144 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 144 resolved as shift
WARNING: shift/reduce conflict for ID in state 149 resolved as shift
WARNING: shift/reduce conflict for IF in state 149 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 149 resolved as shift
WARNING: shift/reduce conflict for FOR in state 149 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 149 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 149 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 149 resolved as shift
WARNING: shift/reduce conflict for TRY in state 149 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 149 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 149 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 149 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 149 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 149 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 149 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 149 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 149 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 149 resolved as shift
WARNING: shift/reduce conflict for VAR in state 149 resolved as shift
WARNING: shift/reduce conflict for CONST in state 149 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 149 resolved as shift
WARNING: shift/reduce conflict for VOID in state 149 resolved as shift
WARNING: shift/reduce conflict for INT in state 149 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 149 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 153 resolved as shift
WARNING: shift/reduce conflict for ID in state 153 resolved as shift
WARNING: shift/reduce conflict for IF in state 153 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 153 resolved as shift
WARNING: shift/reduce conflict for FOR in state 153 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 153 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 153 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 153 resolved as shift
WARNING: shift/reduce conflict for TRY in state 153 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 153 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 153 resolved as shift
WARNING: shift/reduce conflict for VAR in state 153 resolved as shift
WARNING: shift/reduce conflict for CONST in state 153 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 153 resolved as shift
WARNING: shift/reduce conflict for VOID in state 153 resolved as shift
WARNING: shift/reduce conflict for INT in state 153 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 153 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 159 resolved as shift
WARNING: shift/reduce conflict for ID in state 159 resolved as shift
WARNING: shift/reduce conflict for IF in state 159 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 159 resolved as shift
WARNING: shift/reduce conflict for FOR in state 159 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 159 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 159 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 159 resolved as shift
WARNING: shift/reduce conflict for TRY in state 159 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 159 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 159 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 159 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 159 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 159 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 159 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 159 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 159 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 159 resolved as shift
WARNING: shift/reduce conflict for VAR in state 159 resolved as shift
WARNING: shift/reduce conflict for CONST in state 159 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 159 resolved as shift
WARNING: shift/reduce conflict for VOID in state 159 resolved as shift
WARNING: shift/reduce conflict for INT in state 159 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 159 resolved as shift
WARNING: shift/reduce conflict for ID in state 167 resolved as shift
WARNING: shift/reduce conflict for IF in state 167 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 167 resolved as shift
WARNING: shift/reduce conflict for FOR in state 167 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 167 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 167 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 167 resolved as shift
WARNING: shift/reduce conflict for TRY in state 167 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 167 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 167 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 167 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 167 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 167 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 167 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 167 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 167 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 167 resolved as shift
WARNING: shift/reduce conflict for VAR in state 167 resolved as shift
WARNING: shift/reduce conflict for CONST in state 167 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 167 resolved as shift
WARNING: shift/reduce conflict for VOID in state 167 resolved as shift
WARNING: shift/reduce conflict for INT in state 167 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 167 resolved as shift
WARNING: shift/reduce conflict for ID in state 170 resolved as shift
WARNING: shift/reduce conflict for IF in state 170 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 170 resolved as shift
WARNING: shift/reduce conflict for FOR in state 170 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 170 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 170 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 170 resolved as shift
WARNING: shift/reduce conflict for TRY in state 170 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 170 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 170 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 170 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 170 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 170 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 170 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 170 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 170 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 170 resolved as shift
WARNING: shift/reduce conflict for VAR in state 170 resolved as shift
WARNING: shift/reduce conflict for CONST in state 170 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 170 resolved as shift
WARNING: shift/reduce conflict for VOID in state 170 resolved as shift
WARNING: shift/reduce conflict for INT in state 170 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 170 resolved as shift
WARNING: shift/reduce conflict for ID in state 171 resolved as shift
WARNING: shift/reduce conflict for IF in state 171 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 171 resolved as shift
WARNING: shift/reduce conflict for FOR in state 171 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 171 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 171 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 171 resolved as shift
WARNING: shift/reduce conflict for TRY in state 171 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 171 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 171 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 171 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 171 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 171 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 171 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 171 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 171 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 171 resolved as shift
WARNING: shift/reduce conflict for VAR in state 171 resolved as shift
WARNING: shift/reduce conflict for CONST in state 171 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 171 resolved as shift
WARNING: shift/reduce conflict for VOID in state 171 resolved as shift
WARNING: shift/reduce conflict for INT in state 171 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 171 resolved as shift
WARNING: shift/reduce conflict for ID in state 172 resolved as shift
WARNING: shift/reduce conflict for IF in state 172 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 172 resolved as shift
WARNING: shift/reduce conflict for FOR in state 172 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 172 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 172 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 172 resolved as shift
WARNING: shift/reduce conflict for TRY in state 172 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 172 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 172 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 172 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 172 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 172 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 172 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 172 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 172 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 172 resolved as shift
WARNING: shift/reduce conflict for VAR in state 172 resolved as shift
WARNING: shift/reduce conflict for CONST in state 172 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 172 resolved as shift
WARNING: shift/reduce conflict for VOID in state 172 resolved as shift
WARNING: shift/reduce conflict for INT in state 172 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 172 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 173 resolved as shift
WARNING: shift/reduce conflict for ID in state 173 resolved as shift
WARNING: shift/reduce conflict for IF in state 173 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 173 resolved as shift
WARNING: shift/reduce conflict for FOR in state 173 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 173 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 173 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 173 resolved as shift
WARNING: shift/reduce conflict for TRY in state 173 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 173 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 173 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 173 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 173 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 173 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 173 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 173 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 173 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 173 resolved as shift
WARNING: shift/reduce conflict for VAR in state 173 resolved as shift
WARNING: shift/reduce conflict for CONST in state 173 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 173 resolved as shift
WARNING: shift/reduce conflict for VOID in state 173 resolved as shift
WARNING: shift/reduce conflict for INT in state 173 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 173 resolved as shift
WARNING: shift/reduce conflict for ID in state 174 resolved as shift
WARNING: shift/reduce conflict for IF in state 174 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 174 resolved as shift
WARNING: shift/reduce conflict for FOR in state 174 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 174 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 174 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 174 resolved as shift
WARNING: shift/reduce conflict for TRY in state 174 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 174 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 174 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 174 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 174 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 174 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 174 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 174 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 174 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 174 resolved as shift
WARNING: shift/reduce conflict for VAR in state 174 resolved as shift
WARNING: shift/reduce conflict for CONST in state 174 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 174 resolved as shift
WARNING: shift/reduce conflict for VOID in state 174 resolved as shift
WARNING: shift/reduce conflict for INT in state 174 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 174 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 175 resolved as shift
WARNING: shift/reduce conflict for ID in state 175 resolved as shift
WARNING: shift/reduce conflict for IF in state 175 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 175 resolved as shift
WARNING: shift/reduce conflict for FOR in state 175 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 175 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 175 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 175 resolved as shift
WARNING: shift/reduce conflict for TRY in state 175 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 175 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 175 resolved as shift
WARNING: shift/reduce conflict for VAR in state 175 resolved as shift
WARNING: shift/reduce conflict for CONST in state 175 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 175 resolved as shift
WARNING: shift/reduce conflict for VOID in state 175 resolved as shift
WARNING: shift/reduce conflict for INT in state 175 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 175 resolved as shift
WARNING: shift/reduce conflict for RBRACE in state 176 resolved as shift
WARNING: shift/reduce conflict for ID in state 176 resolved as shift
WARNING: shift/reduce conflict for IF in state 176 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 176 resolved as shift
WARNING: shift/reduce conflict for FOR in state 176 resolved as shift
WARNING: shift/reduce conflict for PRINT in state 176 resolved as shift
WARNING: shift/reduce conflict for CLASS in state 176 resolved as shift
WARNING: shift/reduce conflict for ENUM in state 176 resolved as shift
WARNING: shift/reduce conflict for TRY in state 176 resolved as shift
WARNING: shift/reduce conflict for SWITCH in state 176 resolved as shift
WARNING: shift/reduce conflict for INT_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for STRING_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for NUM_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for DOUBLE_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for BOOL_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for LIST_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for MAP_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for SET_TYPE in state 176 resolved as shift
WARNING: shift/reduce conflict for VAR in state 176 resolved as shift
WARNING: shift/reduce conflict for CONST in state 176 resolved as shift
WARNING: shift/reduce conflict for FINAL in state 176 resolved as shift
WARNING: shift/reduce conflict for VOID in state 176 resolved as shift
WARNING: shift/reduce conflict for INT in state 176 resolved as shift
WARNING: shift/reduce conflict for DOUBLE in state 176 resolved as shift
WARNING: reduce/reduce conflict in state 2 resolved using rule (program -> statements)
WARNING: rejected rule (empty -> <empty>) in state 2
WARNING: reduce/reduce conflict in state 21 resolved using rule (statement -> empty)
WARNING: rejected rule (list -> empty) in state 21
WARNING: reduce/reduce conflict in state 21 resolved using rule (statement -> empty)
WARNING: rejected rule (set -> empty) in state 21
WARNING: reduce/reduce conflict in state 21 resolved using rule (statement -> empty)
WARNING: rejected rule (map -> empty) in state 21
WARNING: reduce/reduce conflict in state 76 resolved using rule (factor -> INT)
WARNING: rejected rule (variable -> INT) in state 76
WARNING: reduce/reduce conflict in state 77 resolved using rule (factor -> DOUBLE)
WARNING: rejected rule (variable -> DOUBLE) in state 77
WARNING: reduce/reduce conflict in state 174 resolved using rule (default_case -> DEFAULT COLON statements)
WARNING: rejected rule (empty -> <empty>) in state 174
WARNING: Rule (list -> empty) is never reduced
WARNING: Rule (set -> empty) is never reduced
WARNING: Rule (map -> empty) is never reduced
WARNING: Rule (variable -> INT) is never reduced
WARNING: Rule (variable -> DOUBLE) is never reduced
